# Функциональное программирование

Подготовительный материал к экзамену по лекционным материалам.

## Базовый синтаксис

### Введение

Из основных особенностей языка Haskell можно выделить;

* Статическая типизация
* Иммутабельность (или: неизменяемость объектов)
* Чистота (см. *чистая функция*)
* Отсутствие `null`
* Ленивая модель вычислений (вычисляется тогда и только тогда, когда нужно). Одна из особенностей: можно создавать *бесконечные списки*.

**Чистая функция** - эта та функция, которая зависит только от своих аргументов и на одних и тех же аргументов она всегда выдаёт один и тот же результат. Компилятор может на уровне типов увидеть, насколько чиста данная функция (например, тип `IO` говорит, что функция нечиста).

### Арифметика и типы

Некоторые базовые арифметические выражения, логика и сравнения:

```haskell
ghci> 1 + 2 + 3
7
ghci> 3 / 5 * (7 + 1)
4.8
ghci> 2 ^ 16
65536
ghci> 1 + 1 == 3
False
ghci> 2 + 2 /= 5
True
ghci> 21 * 22 <= 20 * 23
False
ghci> 1 < 2 && 2 < 3
True
ghci> 0 > 0 || 10 >= 10
True
```

Вызов функций: все аргументы разделены через пробельный символы и не обособляются скобками.

```haskell
ghci> not True
False
ghci> div 7 3 -- integral division
2
ghci> max 3 5
5
ghci> min 6 (10 * 2)
6
```

Иногда стоит задумываться о группировках аргументов: в Haskell у применения функции приоритет всегда выше, чем у любого другого оператора.

```haskell
ghci> div 7 3 + 1
3
ghci> div 7 (3 + 1)
1
ghci> div 7 + 1 3
-- *** Compilation error!
ghci> div (7 + 1) 3
2
```

И функции, и операторы мы можем использовать как в *префиксной* записи, так и в *инфиксной*:

* оператор в префиксной записи необходимо обернуть в `()`
* функцию в инфиксной записи необходимо обернуть в `` (кавычки)

```haskell
ghci> 3 + 4
7
ghci> (+) 3 4
7
ghci> mod 7 3
1
ghci> 7 `mod` 3
1
```

Определение переменных (*констант*, так как они неизменяемы). В новых нынешних версиях:

```haskell
ghci> x = 7 + 8
ghci> x * 2
30
```

Помимо целочисленных/нецелочисленных чисел и логических типов в Haskell есть также строковый тип `String`.

```haskell
ghci> greeting = "Hello"
ghci> greeting ++ " world!" -- use `++` instead of `+` to concatenate strings
"Hello world!"
ghci> "DONE: say \"" ++ greeting ++ " world!\""
"DONE: say "Hello world!""
```

В Haskell большое внимание выделяется *типам*. Обычно говорят, что если программа *компилируется*, то она работает правильно. Для определения типа выражения в GHCi используется команда `:t`.

```haskell
ghci> :t 'x'
'x' :: Char
ghci> :t False
False :: Bool
ghci> :t not
not :: Bool -> Bool
ghci> :t (&&)
(&&) :: Bool -> Bool -> Bool
ghci> :t 42
42 :: Num t => t -- числовые константы полиморфны
```

В последнем примере есть интересная деталь: мы не знаем, какой тип `t` в выражении `42 :: Num t => t` до тех пор, пока нам неизвестен *контекст* выражения, то есть, если бы мы передали `42` в функцию, которая принимает `Int`, тогда `t` был бы выведен в `Int`. Это и называется *полиморфизм*.

### Функции

Определим функцию `addMul`, которая будет принимать три числа, умножать второе на третье суммировать с первым.

```haskell
addMul :: Int -> Int -> Int -> Int
addMul x y z = x + y * z
```

Как правильно, для определения функции мы пишем сначала её сигнатуру (или: её тип) - `addMul :: Int -> Int -> Int -> Int` - здесь `::` можно читать как "имеет тип", принимает три `Int` и возвращает тип `Int`; далее само определение: название функции, имена параметров с соответствующем порядке типов, после `=` пишем тело функции.

Или другой пример, функция `greet`: принимаем строку, возвращаем строку, в качестве параметра принимаем `name :: String`.

```haskell
greet :: String -> String
greet name = "Hello, " ++ name ++ "!"
```

Для загрузки модуля в GHCi мы используем команду `:l` для первоначальной и `:r` для перезагрузок, если модуль был изменен.

```haskell
ghci> :l Lecture.hs
ghci> addMul 1 2 3
7
ghci> greet "Haskell"
"Hello, Haskell!"
```

### Операторы

В Haskell можно создавать свои собственные операторы с своими собственными приоритетами (от 0 до 10, сам приоритет в порядке возрастания). Они могут быть как левоассоциативными, так и правоассоциативными, так и не те, и не те (и то другое).

```haskell
-- где-то в пакете `base`
infixr 2 ||
(||) :: Bool -> Bool -> Bool
(||) left right = ...
```

Для определения оператора мы сначала пишем одно из трех ключевых слов `infix`/`infixl`/`infixr`, определяющий *ассоциативность оператора*, затем его *приоритет*, далее *название оператора*, наконец - мы пишем его *тип* и *тело оператора*.

Попробуем задать оператор импликации, у него приоритет ниже, чем у `||`, она правоассоциативна и с названием `==>`. Получаем:

```haskell
infixr 1 ==> -- если оставить только это (убрать тип и тело), то будет ошибка компиляции
(==>) :: Bool -> Bool -> Bool
a ==> b = not a || b -- `a ==> b` эквивалентно `(==>) a b`
```

Оператор **не может быть не-бинарным**, оператор, по определению, это **бинарная операция**. Также, приоритет **не может быть нецелым числом**, всегда **целое**; максимальный задаваемый приоритет - это **`9`**, оператор `пробел` - *применение функции* - имеет наивысший приоритет **`10`**.

Итого, по ассоцитивности оператор в Haskell получается следующее:

$$
\begin{align*}
\mathtt{infixl} : a \circ b \circ c \circ d &\equiv ((a \circ b) \circ c) \circ d \\
\mathtt{infixr} : a \circ b \circ c \circ d &\equiv a \circ (b \circ (c \circ d)) \\
\mathtt{infix} : a \circ b \circ c \circ d &\equiv \textit{Compilation error}
\end{align*}
$$

Для последнего нам придется сами расставлять скобки.

### Тип `List`

Определение списка осуществляется через перечисление его аргументов через запятую.

```haskell
ghci> [1 + 2, 3 + 4, 5 * 6]
[3, 7, 10]
```

Некоторые полезные операторы при работе с списками.

```haskell
ghci> list = [2, 1, 3] -- создали `list` переменную
ghci> [5, 10] ++ list  -- конкатенация двух списков с помощью оператора `++``
[5, 10, 2, 1, 3]       -- напоминание: Haskell иммутабельный, а потом переменная `list` не была изменена
ghci> 10 : list        -- второй метод конкатенации, когда мы присоединяем к голове списка один элемент
[10, 2, 1, 3]
```

Под капотом при конкатенации списков мы не полностью копируем списки, внутри мы используем древовидный вид списков для более быстрого изменения (как персистентные структуры данных). Работают почти также, как в Clojure.

Ещё некоторые примеры работы для понимания, что `List` иммутабельный.

```haskell
ghci> list
[2, 1, 3]
ghci> reverse list -- не изменяет переменную `list`
[3, 1, 2]
ghci> list
[2, 1, 3]
ghci> anotherList = 5 : list -- новая переменная
ghci> anotherList
[5, 2, 1, 3]
ghci> list
[2, 1, 3]
```

Рассмотрим ещё некоторые примеры при работе с списками.

```haskell
emptyList :: [Int] -- если у функции 0 аргументов, значит, перед нами константа
emptyList = [] -- пустой список

singletonList :: [Int]
singletonList = 1 : emptyList -- или: [1]

listExample :: [Int]
listExample = [2, 1, 3] -- или: 2:1:3:[], на самом деле `[2, 1, 3]` - это синтаксический сахар

listExample' :: [Int]
listExample' = 5:10:listExample -- или: [5, 10, 2, 1, 3]

twoLists :: [Int]
twoLists = singletonList ++ listExample -- [1, 2, 1, 3]

trinity :: [Int]
trinity = listExample ++ [7] ++ twoLists -- [2, 1, 3, 7, 1, 2, 1, 3]
```

Обратим внимание на знакомый тип `String` и сравним его с `List`.

```haskell
string :: [Char] -- `String` - на самом деле, это [Char]
string = "str" -- ['s', 't', 'r']

otherString :: String -- [Char]
otherString = "other" ++ " " ++ string -- "other str"
```

Поскольку, `String` - это *alias* над списком символом, то довольно очевидно, почему это так:

```haskell
ghci> "" == []
True
-- `""` - это пустой [Char]
-- `[]` - это полиморфный тип, который выводится в [Char]
```

У списков в Java и в других языках программирования можно задать *range*.

```java
IntStream.range(0, 5).toArray(); // {0, 1, 2, 3, 4};
IntStream.rangeClosed(0, 5).toArray(); // {0, 1, 2, 3, 4, 5};
IntStream.iterate(0, x -> x + 2).limit(5).toArray(); // {0, 2, 4, 6, 8};
```

Тоже самое можно задать в Haskell.

```haskell
[0 .. 5]     -- [0, 1, 2, 3, 4, 5], правая граница всегда включена
[1, 3 .. 5]  -- [1, 3, 5, 5], для указания шага достаточно первых двух элементов

[0..]        -- [0, 1, 2, 3, ...] - бесконечный список, не будет вычисляться честным образом
[0, 2 ..]    -- [0, 2, 4, 6, ...] - все четные числа, также не будет вычисляться честным образом

[5, 4, .. 1] -- [5, 4, 3, 2, 1], важно, что
[5 .. 1]     -- [] - пустой список
```

Для списков определены некоторые стандартные функции. Рассмотрим для получения доступа к элемента, пусть `list = [2, 1, 3]`.

```haskell
ghci> head list -- возвращает первый элемент из списка; работает за O(1)
2

ghci> tail list -- возвращает все остальные, кроме первого элемента; работает за O(1)
[1, 3]

ghci> last list -- возвращает последний элемент; работает за O(n)
3

ghci> init list -- возвращает все остальные, кроме последнего; работает за O(n)
[2, 1]
```

**Дисклеймер**: лучше не использовать данные функции, так как они небезопасны в чистых функциях. Например, при пустом списке `head` и `tail` могут бросить исключение.

Рассмотрим функции из модуля `Prelude`.

```haskell
ghci> drop 2 [2, 1, 3] -- если вместо 2 поставить 1000, вернётся пустой список; альтернативная реализация `tail`: `drop 1`
[3]

ghci> take 1 [2, 1, 3] -- если вместо 1 поставить 1000, вернётся весь список
[2]

ghci> replicate 3 [1..5] -- может принимать не только `List` в качестве второго аргумента
[[1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5]]

ghci> zip [1, 2, 3] "abc" -- составление соответствующих пар из двух списков, если какой-то из них оказался короче, то длина результирующего списка = длина короткого
[(1, 'a'), (2, 'b'), (3, 'c')] -- `(1, 'a')` - это пара типа Num t => (t, Char)

ghci> unzip [(5, True), (10, False)] -- делает ровно наоборот в отличии от `zip`
([5, 10], [True, False])

ghci> words "Hello,     Haskell   \t\n\n  world!" -- принимает `String` и делает разделение по пробельным символам
["Hello,", "Haskell", "world!"]

ghci> unwords ["Hello,", "Haskell", "world!"] -- делает ровно наоборот в отличии от `words`, в качестве разделителя используется пробел
"Hello, Haskell world!"

ghci> [2, 1, 3] !! 2 -- l !! i = l[i], работает за O(i); не стоит использовать
3 
```

### Конструкции и выражения

**Конструкция** во многих языках программирования - это управляющая конструкция языка, которая не имеет возвращаемого значения и типа. **Выражение** - наоборот - имеет возвращаемое значение. Например, `2 + 3` - это выражение, результат которого `5` арифметического типа; а, например, `if` в C++ - это конструкция, управляющая часть языка, оно не имеет возвращаемого типа и значения.

```c++
void f (); // определение функции - это конструкция

int random() {
    return 4; // `return` - это конструкция, `4` - это выражение
}

int main() {
    int a = random(); // определение переменной - это конструкция, `random()` - это выражение
    if (a > 0) { // `if` - это конструкция, `a > 0` - это выражение
        printf("C++"); // вызов функции без явного контекста может быть как конструкцией, так и выражением
    }
}
```

Большинство конструкций в императивных языках программирования - это выражения в Haskell.

#### `let`

Предположим, что у нас есть функция $pythagoras(x, y) = x^2 + y ^2$, которая принимает два целочисленных значения и возвращает сумму их квадратов.

```haskell
pythagoras :: Int -> Int -> Int
pythagoras x y = x^2 + y^2
```

С помощью конструкции вида $\texttt{let}~bindings~\texttt{int}~expression$ мы можем объявить после `let` какие-то промежуточные индификаторы, а после `in` записать выражение, где мы можем применять данные bind'инги.

```haskell
pythagoras :: Int -> Int -> Int
pythagoras x y = let x2 = x ^ 2 -- важное замечание про форматирование: только пробелы и только верное их число
                     y2 = y ^ 2
                 in x2 + y2
```

#### `where`

Рассмотрим максимально нагруженный пример на Java.

```java
double pythagoras(double a, double b) {
    class Squarer {
        double eval(double x) {
            return x * x;
        }
    }

    final double a2 = new Squarer().eval(a);
    final double b2 = new Squarer().eval(b);

    return a2 + b2;
}
```

Тоже самое мы можем написать в Haskell, используя конструкцию `where`.

```haskell
pythagoras :: Double -> Double -> Double
pythagoras a b = a2 + b2
  where
    square x = x ^ 2
    a2 = square a
    b2 = square b
```

Заметим, что (как и в `let`) в части *binding* мы можем писать не только константы (индификаторы), но и целые функции. То есть, мы объявили функцию `square`, которая возвращает квадрат значения, а затем две константы как вызов функции.

Заметим, что мы не объявляли (хотя, нам никто не запрещает) тип у функции `square` - компилятор сможет сам догадаться по входным значениям. Также, иногда, мы можем опускать типы у самих определений функций (но лучше так не надо делать).

**Важно**: конструкция `where` **не является выражением** - это набор определений, которые относятся к нашим функциям, в отличии от `let`-`in`.

#### `if`

Конструкция `if` **является выражением** в отличие от C++ и имеет следующую сигнатуру записи: $\texttt{if}~predicate~\texttt{then}~experession~\texttt{else}~expression$. Мы можем использовать его в функциях.

```haskell
factorial :: Integer -> Integer -- `Integer` это неограниченно большое число, в отличии от `Int` - платформозависмый (32/64 бита)
factorial n = if n <= 1
              then 1
              else n * factorial (n - 1)
```

В каком-то плане такой `if` - это *тернарный оператор* как в других языках программирования.

**Важно**: выражения, находящиеся после `then` и `else` всегда **должны быть одинаковых типов**, так как у нас строгая типизация.

#### guards

Рассмотрим максимально нагруженный пример на Java.

```java
public int collatzSum(int n) {
    if (n < 0) {
        return 0;
    } else if (n == 1) {
        return 1;
    } else if (n % 2 == 0) {
        return n + collatzSum(n / 2);
    } else {
        return n + collatzSum(3 * n + 1);
    }
}
```

В Haskell мы можем также написать, но для таких лучше использовать так называемые *guard* выражения.

```haskell
collatzSum :: Natural -> Natural
collatzSum n
  | n == 1 = 1
  | even n = n + collatzSum (n `div` 2)
  | otherwise = n + collatzSum(3 * n + 1)
```

Мы также пишем определение функции `collatzSum`, пишем аргумент `n`, однако, вместо `=` и привычного тела мы пишем условия через `|` (вертикальная черта):

* в случае, если `n == 1`, тогда нашим телом будет `1`
* в случае, если `n` четное (`even` - стандартная функция), тогда телом будет `n + collatzSum (div n 2)`
* наконец, в любом другом случае, `n + collatzSum(3 * n + 1)`; `otherwise` - это константа `True`

Проверка условий идет всегда сверху-вниз, то есть если после `otherwise` будет ещё какое-то условие, то мы получим недостижимое тело функции.

#### `case`

Рассмотрим максимально нагруженный пример на Java.

```java
public String getFont(int fontConstant) {
    String font = null;
    switch (fontConstant) {
        case 0: font = "PLAIN"; break;
        case 1: font = "BOLD"; break;
        case 2: font = "ITALIC"; break;
        default: font = "UNKNOWN";
    }
    return font;
}
```

В Haskell также есть конструкция `case`, которая на самом деле также **является выражением**. Записывается она вот так: $\texttt{case}~expression~\texttt{of}~\left[pattern~\texttt{->}~expression\right]$, то есть мы сопоставляем нечто (первый *expression*) с некоторым из *pattern*'ов и вернуть новый *expression*.

```haskell
getFont :: Int -> String
getFont n = case n of
              0 -> "PLAIN"
              1 -> "BOLD"
              2 -> "ITALIC"
              _ -> "UNKNOWN" -- аналог default, `underscore` - это один из способов наименования значения
```

Принципиальная разница между `case` и guard выражениями: guard проверяет *логическую истинность* `Bool`-выражения, в то время как `case` проверяет *соответствие значению-паттернов*. Можем переписать на guard-стиль.

```haskell
getFont :: Int -> String
getFont n
  | n == 0 = "PLAIN"
  | n == 1 = "BOLD"
  | n == 2 = "ITALIC"
  | otherwise = "UNKNOWN"
```
