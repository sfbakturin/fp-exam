# Basic type-classes

## Type class

### Полугруппа и Моноид

Вспомним линейную алгебру. У нас есть некоторое замкнутое множество, на нем определены определенные ассоциативные бинарные операции. Такую структуру мы называем **полугруппой**.

Но поскольку мы работаем с типами, а не со множествами, потому мы можем определить в языке *type class* `Semigroup`, принимающая тип `m`, на которой определена операция, которая берет элементы типа `m` и возвращает `m` (это и есть *замкнутость* на типах).

```haskell
class Semigroup m where
  (<>) :: m -> m -> m
```

Для полугруппы определено свойство ассоциативности.

```haskell
(x <> y) <> z = x <> (y <> z)
```

В качестве примера из математики, обладающие свойством полугруппы можно привести функцию максимума/минимума.

В Haskell мы никаким образом не можем определить ту или иную верность операции на поставляемых свойствах структуры, потому ответственность за правильность работы лежит исключительно на программисте.

**Моноидом** мы называем полугруппу с определенным нейтральным элементом. В Haskell мы бы записали type-class `Monoid` как constraint `Semigroup`.

```haskell
class Semigroup m => Monoid m where
  mempty :: m
```

Для моноида определены ассоциативность и нейтральность элемента.

```haskell
x <> mempty = x
mempty <> x = x
```

Поскольку `Monoid` - это подкласс полугруппы `Semigroup`, для того, чтобы определить instance некоторого типа данных, необходимо определить instance полугруппы (чтобы для него был доступен оператор `(<>)`).

Примером моноида в Haskell можно привести тип списка, так как там есть ассоциативный оператор `(++)` и нейтральный элемент в виде пустого списка.

Посмотрим поглубже в type-class полугруппы.

```haskell
class Semigroup m where
  (<>)    :: m -> m -> m
  sconcat :: NonEmpty m -> m
  stimes  :: Integral b => b -> m -> m
```

Помимо `(<>)` у нас определены ещё две функции, обе сделаны через основной оператор:

* `sconcat` берёт *не пустой* список (то есть, тот, где есть хотя бы один элемент) и склепывает его по `(<>)`, то есть: `[a1, a2 .. an]` превращается в `a1 <> a2 <> .. <> an`
* `stimes` действует как *умножение*: мы хотим взять элемент `m` и сложить его с собой `b` раз, тогда: `stimes n x = x <> x <> ... <> x`

Рассмотрим instance для списков.

```haskell
instance Semigroup [a] where
  (<>) = (++) -- конкатенация двух списков
```

Возникает интересный вопрос по поводу полугрупп. Мы знаем, что `Int` также может являться полугруппой для операций умножения и сложения - но какой выбрать? Хотим иметь возможность использовать и то, и другое.

Легальный способ заиметь оба instance'а одновременно - это обернуть типы (`newtype`) над типом `a` (это может быть тот же `Int`) и для этих отдельных типов данных мы определяем instance полугруппы.

```haskell
newtype Sum a = Sum { getSum :: a }
newtype Product a = Product { getProduct :: a }
-- напоминание: { name :: type } - это именнованные поля,
-- на самом деле, это функция name :: Type type -> type
```

```haskell
instance Num a => Semigroup (Sum a) where
  Sum x <> Sum y = Sum (x + y)
  -- для того, чтобы мы смогли сложить,
  -- возникает constraint от нумерического типа

instance Num a => Semigroup (Product a) where
  Product x <> Product y = Product (x * y)
  -- для того, чтобы мы смогли умножить,
  -- возникает constraint от нумерического типа
```

Пример использования.

```haskell
ghci> 3 <> 5 :: Sum Int
Sum { getSum = 8 }

ghci> 3 <> 5 :: Product Int
Product { getProduct = 15 }
```

На самом деле, instance'ев полугруппы у нас бывает много, из-за свойств предлагаемых операций. Например,

```haskell
newtype Max a = Max { getMax :: a } -- max
newtype Min a = Max { getMin :: a } -- min
-- в этом случае, тип `a` должен быть instance от `Ord`

newtype Any = Any { getAny :: Bool } -- ||
newtype All = Any { getAll :: Bool } -- &&

newtype First a = First { getFirst :: Maybe a } -- first Just
-- `First` - обёртка под `Maybe`, которая возвращает первый `Just`
-- из цепочки `Maybe` применения `(<>)`
newtype Last a = Last { getLast :: Maybe a } -- last Just
-- `Last` - точно также с `First`, только возвращает последний `Just`
```

Посмотрим поглубже в type-class моноида.

```haskell
class Semigroup m => Monoid m where
  mempty  :: a
  mappend :: a -> a -> a
  mconcat :: [a] -> a
```

У нас появляются ещё две функции:

* `mappend` - по умолчанию (то есть, его не нужно снова прописывать именно для моноида), это - оператор `(<>)`
* `mconcat` - похож на `sconcat`, только список *может быть пустым* - разница в том, что если в `mconcat` мы подаем пустой список, то получаем нейтральный элемент `mempty`

Рассмотрим instance для списков.

```haskell
instance Monoid [a] where
  mempty = [] -- конкатенация списка с пустым даст тот же список
  mappend l1 l2 = l1 ++ l2 -- можно не писать, так как это - `(<>)`
```

Можно также создать моноид пары только в том случае, если каждый элемент в ней - это моноид.

```haskell
instance (Monoid a, Monoid b) => Monoid (a, b) where
  mempty = (mempty, mempty)
  mappend (a1, b1) (a2, b2) = (mappend a1 a2, mappend b1 b2)
```

### Свёртка

В этой части мы будем рассматривать две функции `foldr` и `foldl` - суть их почти одинакова, первое - это правая свёртка, второе - левая. На самом деле, `foldr` - это, так называемый, *элиминатор списка*.

**Элиминатор** - функция, которая преобразует некоторый алгебраический тип `a` в произвольный тип `b`.

Попробуем вывести тип функции `foldr`.

1. У нас есть тип `List`, определенный следующим образом:

    ```haskell
    data List a = Nil | Cons (List a)
    ```

2. `Nil` имеет тип `List a` - мы хотим его преобразовать в `b`:

    ```haskell
    Nil :: List a ~~>> b
    ```

3. Далее, у нас есть `Cons` имеет тип `a -> List a -> List a` - также хотим его преобразовать в `b`:

    ```haskell
    Cons :: a -> List a -> List a ~~>> a -> b -> b
    ```

4. Наконец, поскольку у `List` есть два конструктора, необходимо их совместить как элиминатор нашего списка:

    ```haskell
    listElim :: [a] -> b
    ```

    Внимание: у списка *два* конструктора, каждому из них сопоставляется типы `b` и `a -> b -> b` преобразованные, и они записываются в качестве аргументов

    ```haskell
    listElim :: (a -> b -> b) -> b -> [a] -> b
    ```

Мы вывели тип так называемой *правой свёртки* (`foldr`) по переданной бинарной функции преобразования и стартовому значению свёртки следующим образом:

> поставить картинку

Здесь - вместо условного `Cons` мы подставляем функцию `f`, вместо конца списка (`Nil`) - `z`.

*Левая свёртка* (`foldl`) очень похожа на правую.

> поставить картинку

Однако, тут мы конструируем цепочки применения левоассоциативно (поэтому, `b -> a -> b`).

Для элиминатора списка существует обобщение в виде элиминатора нечто...

```haskell
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b
```

Для того, чтобы понять, что такое `t a`, где у `t` есть constraint `Foldable` нам нужно поглубже посмотреть на типы. Мы знаем, что у любого значения есть тип:

```haskell
ghci> :t True
True :: Bool
```

Где `Bool` - это логический *тип*. Можно ли продолжить цепочку? Можно.

```haskell
ghci> :k Bool
Bool :: Type
```

Вроде бы логично, но почему `:k`? Потому что *тип типа*, с точки зрения теории, называется **родом** (или: **kind**).

Тогда, для `Int` родом будет также являться `Type`. Такая же ситуация с `Maybe Int` - его род это тот же `Type`. А какой kind у `Maybe`? Посмотрим внимательно на `Maybe`: он принимает тип, а тип `Int` явно является `Maybe Int` тем самым принимаемым типом, но тогда наш `Maybe` принимает тип и возвращает тип.

```haskell
ghci> :k Maybe Int
Maybe Int :: Type

ghci> :k Maybe
Maybe :: Type -> Type
```

Получаем функции на типах. Посмотрим теперь на `Either () Char` - его род, очевидно, это `Type`. А просто `Either ()`? Как и с `Maybe`: `Either () :: Type -> Type`. Наконец, какой род у `Either`? `Type -> Type -> Type`.

```haskell
ghci> :k Either () Char
Either () Char :: Type

ghci> :k Either ()
Either () :: Type -> Type

ghci> :k Either
Either :: Type -> Type -> Type
```

Зададим `IdentityT` следующим образом и сразу посмотрим на его род.

```haskell
ghci> data IdentityT m a = IdentityT (m a)
ghci> :k IdentityT
IdentityT :: forall {k}. (k -> Type) -> k -> Type
```

Посмотрим на определение `IdentityT`: тут тип `m` принимает `a`, тогда `m` должен быть типом так называемым *типом высшего рода* (так как он принимает другой тип). Более того, `a` - это какой-то произвольный тип `k`, тогда `m` - это тип, род которого `k -> Type` - почему обязательно в `Type` - потому что по умолчанию все `data` возвращают `Type`.

Рассмотрим теперь род у класса `Num`.

```haskell
ghci> :k Num
Num :: Type -> Constraint
```

Он принимает `Type`, так как сам класс `Num` принимает тип `a`, а возвращает `Constraint` - это также тип, но про него будет позже.

Наконец, посмотрим на род `Foldable`.

```haskell
ghci> :k Foldable
Foldable :: (Type -> Type) -> Constraint
```

Он принимает `(Type -> Type)`, так как это *контейнер*, и возвращает `Constraint`, так как он - `class`.

Вернемся к свёрткам, а именно приведем пример использования правой свёртки: `foldr (*) 3 [2, 1, 10]`. Его начальное значение (то есть, `z` из картинки выше) - это `3`, тогда данный вызов развернётся в: `2 * 1 * 10 * 3`.

```haskell
ghci> foldr (*) 3 [2, 1, 10]
60
```

Посмотрим глубже на класс `Foldable`. Минимальный и простой вариант состоит из нескольких функций.

```haskell
class Foldable t where
  fold :: Monoid m => t m -> m -- эквивалентно `foldMap id`
  foldMap :: Monoid m => (a -> m) -> t a -> m
  foldr :: (a -> b -> b) -> b -> t a -> b
```

Здесь интересен `foldMap`: он берёт контейнер (или: *контекст*), возвращает моноид и в качестве первого аргумента мы берем функцию, которая умеет трансформировать элемент контейнера в моноид.

Рассмотрим instance `Foldable` для списка.

```haskell
instance Foldable [] where
  foldr :: (a -> b -> b) -> b -> [a] -> b
  foldr _ z [] = z
  foldr f z (x:xs) = f x (foldr f z xs)
```

Мы получили буквально рассмотренный ранее элиминатор списка:

* на пустом списке мы возвращаем стартовое значение (или: аккумулятор)
* на непустом применяем `f` в голове и рекурсивно вызываемся на хвосте

Рассмотрим instance `Foldable` для типа `Maybe`.

```haskell
instance Foldable Maybe where
  foldr :: (a -> b -> b) -> b -> Maybe a -> b
  foldr _ z Nothing = z
  foldr f z (Just x) = f x z
```

Определили свёртку следующим образом, мы:

* либо возвращаем наш аккумулятор (ничего не делаем) на `Nothing`
* либо, если есть значение, применяем функцию и возвращаем новое значение

### Functor

Рассмотрим простой случай применения функции к некоторому значения: например, к `2` прилетает `(+3)` и мы честно получаем `5`, так как мы просто будем иметь выражение в виде `3 + 2`. А теперь представим, что значение `2` спрятано где-то в контейнере/контексте и просто так применить функцию сложения будет не просто (банально потому, что мы не можем определить оператор сложения между числовым и внезапной `data`). Тогда мы захотели бы волшебную функцию `fmap`, которая смогла бы пропихнуть функцию `(+3)` и изменить значение внутри контекста, **при этом**, не меняя сам контекст.

В качестве контекста можно привести `Maybe`.

```haskell
ghci> fmap (+3) (Just 2)
Just 5

ghci> fmap (+3) Nothing
Nothing
```

В общем случае, мы имеем тип `f`, чей род это `Type -> Type`, который и является тем самым контекстом.

```haskell
class Functor f where
  fmap :: (a -> b) -> f a -> f b
  -- мы принимаем унарную функцию и возвращаем функцию, которая
  -- возвращает контекст
```

У класса `Functor` имеются два основных правила, из-за которых он является **левоморфизмом**:

1. `fmap id` - эквивалентно `id`
2. `fmap (f . g)` эквивалентно `fmap f . fmap g`

Рассмотрим instance `Functor` для типа `Maybe`.

```haskell
instance Functor Maybe where
  fmap :: (a -> b) -> Maybe a -> Maybe b
  fmap f (Just x) = Just (f x)
  -- у нас есть значение - применим на него функцию и не потеряем
  -- контекст `Just`
  fmap _ Nothing  = Nothing
```

Подобно оператору `($)` существует левоассоциативный оператор `(<$>)`, который применяет `fmap`, для упрощения записи.

```haskell
infixl 4 <$>
(<$>) :: Functor f => (a -> b) -> f a -> f b
(<$>) = fmap
```

Рассмотрим instance `Functor` для списка.

```haskell
instance Functor [] where
  fmap :: (a -> b) -> [a] -> [b]
  fmap = map
  -- пропихиваем функцию к каждому элементу из списка
```

На самом деле, функция (то есть, оператор `(->)`) также является типом данных, они принимает аргумент (первый тип) и результат (второй тип). Поэтому, у самой по себе функции родом будет `Type -> Type -> Type`. Если мы применим к стрелке один аргумент, например, `Int`:

```haskell
ghci> :k (->) Int
(->) Int :: Type -> Type
```

Заметим, что такой kind - `Type -> Type` - подходит для instance'а `Functor`.

```haskell
instance Function ((->), r) where
  fmap :: (a -> b) -> (r -> a) -> r -> b
  fmap = (.) -- композиция двух функций `f` и `g`
```

### Applicative

У нас есть функции `a -> b`, где `b` - произвольный тип, и вместо значения мы можем легко подставить любую другую функцию и получить `a -> (b -> c)`. Например, здесь функцию `(*)` имеет тип как бинарная функция `a -> a -> a`, мы здесь ещё применяем на `Just` и получаем `Just` от функции:

```haskell
ghci> fmap (*) (Just 3) == Just (3 *)
-- Just (Int -> Int)

ghci> :t fmap (++) (Just "hey")
fmap (++) (Just "hey") :: Maybe ([Char] -> [Char])

ghci> :t fmap compare (Just 'a')
fmap compare (Just 'a') :: Maybe (Char -> Ordering)
```

В чем проблема? В том, что в какой-то момент у нас возникнет `Just (a -> b)` - и как нам применять `fmap` - непонятно. Возникает потребность создать новый класс типов, которые назвали `Applicative` - это подкласс `Functor`.

```haskell
class Functor f => Applicative f where
  pure :: a -> f a
  -- оборачивает значение в контекст
  (<*>) :: f (a -> b) -> f a -> f b
  -- это та самая странная функция с контекстом функции
  liftA2 :: (a -> b -> c) -> f a -> f b -> f c
  -- появился, начиная с GHC 8.2.1, может быть выражен как `(<$>)`
  -- `(<$>)` также может быть выражен как `liftA2`
```

Рассмотрим instance `Applicative` для `Maybe`.

```haskell
instance Applicative Maybe where
  pure :: a -> Maybe a
  pure = Just
  -- создали новый контекст, обернув в `Just`

  (<*>) :: Maybe (a -> b) -> Maybe a -> Maybe b
  Nothing <*> _         = Nothing
  Just f  <*> something = fmap f something
  -- если функция пуста, то мы возвращаем `Nothing`,
  -- иначе - пытаемся её применить
```

Рассмотрим instance `Applicative` для списков.

```haskell
instance Applicative [] where
  pure :: a -> [a]
  pure x = [x]
  -- создали новый контекст как singleton

  (<*>) :: [a -> b] -> [a] -> [b]
  fs <*> xs = [f x | f <- fs, x <- xs]
  -- проходимся по всем функциям и применяем к каждому элементу
  -- все это кладем в один список
```

Примеры с `Applicative []` для понимания.

```haskell
ghci> [(*2), (+3)] <*> [1, 2, 3]
[2, 4, 6, 4, 5, 6]

ghci> (*) <$> [2, 5, 10] <*> [8, 10, 11]
[16, 10, 22, 40, 50, 55, 80, 100, 110]
-- мы сначала пропихиваем функцию `(*)` на список, получаем список
-- функций, а затем делаем `(<*>)`
```

Рассмотрим instance `Applicative` для функций. Заметим, что `((->) r)` имеет род `Type -> Type`, что нам подходит для `Applicative`. Причем, `pure` и `<*>` в точности аксиомы из математической логики - изоморфизм Карри-Хорворда.

```haskell
instance Applicative ((->) r) where
  pure :: a -> r -> a
  pure x = \_ -> x

  (<*>) :: (r -> a -> b) -> (r -> a) -> r -> b
  f <*> g = \x -> f x (g x)
```

У `Applicative` есть согласованные с программистами правила:

1. Тождество: `pure id <*> v = v`
2. Композиция: `pure (.) <*> u <*> v <*> w = u <*> (v <*> w)`
3. Гомоморфизм: `pure f <*> pure x = pure (f x)`
4. Обмен: `u <*> pure y = pure ($ y) <*> u`

### Alternative

В абстрактном смысле, `Alternative` - это моноид на `Applicative`-функциях.

```haskell
class Applicative f => Alternative f where
  empty :: f a
  (<|>) :: f a -> f a -> f a
```

Здесь мы получаем `empty` как нейтральный элемент моноида и новый оператор `(<|>)`, который обычно называют как *or-else*. В чем смысл? Это такой класс типов, у которых есть ошибочные представления/вычисления. Это хорошо видно на instance от типа `Maybe`.

```haskell
instance Applicative Maybe where
  empty :: Maybe a
  empty = Nothing
  -- создали пустое-ошибочное состояние

  (<|>) :: Maybe a -> Maybe a -> Maybe a
  Nothing <|> r = r
  l <|> _       = l
  -- вернем правого, если левый - это ошибка
  -- вернем левого, в ином случае
```

При таком определении, мы с помощью `Applicative Maybe` можем вернуть первый `Just` из списка.

```haskell
ghci> Nothing <|> Just 3 <|> empty <|> Just 5
Just 3
```

Рассмотрим instance `Alternative` на списках.

```haskell
instance Alternative [] where
  empty :: [a]
  empty = []

  (<|>) :: [a] -> [a] -> [a]
  (<|>) = (++)
```

`Alternative` на списках - это тот же `Monoid`.

### Traversable

Данный type-class позволяет проходится по некоторому контейнеру `t a` (где, `Foldable t`) и, сохраняя структуру нашего контейнера, коллекционируем результаты в `Applicative`-контекст `f`.

```haskell
class (Functor t, Foldable t) => Traversable t where
  traverse  :: Applicative f => (a -> f b) -> t a -> f (t b)
  sequenceA :: Applicative f => t (f a) -> f (t a)
  -- поменять местами контексты
```

Рассмотрим instance `Traversable` на `Maybe`.

```haskell
instance Traversable Maybe where
  traverse :: Applicative f => (a -> f b) -> Maybe a -> f (Maybe b)
  traverse _ Nothing  = pure Nothing
  -- нам передали `Nothing` в качестве значения, но мы хотим
  -- вернуть `f (Maybe b)`, у `Maybe a` нету никакого значения `a`,
  -- `f` - `Applicative`-контекст, тогда мы можем создать `Maybe b`
  -- с помощью `Nothing`, а `f` - это контекст и мы можем использовать
  -- функцию `pure` для конструирования контекста
  traverse f (Just x) = Just <$> f x
  -- нам передали значение, теперь `x` типа `a`, тогда мы можем
  -- применить поданную функцию и получим `f b`, теперь мы хотим
  -- превратить из `f b` в `f (Maybe b)`, для этого, для того, чтобы
  -- сохранить контекст, мы должны сделать `fmap` по функции из `b -> Maybe b`
```

Рассмотрим instance `Traversable` на списков.

```haskell
instance Traversable [] where
  traverse :: Applicative f => (a -> f b) -> [a] -> f [b]
  traverse f = foldr consF (pure [])
    where
      consF x ys = (:) <$> f x <*> ys
  -- если список пустой, то мы возвращаем `pure []`, в ином же случае,
  -- голова имеет тип `a`, хвост - `[a]`, тогда `f a` - это один элемент
  -- типа `f b`, чтобы получить `f [b]` необходимо рекурсивно вызваться
  -- `traverse`'ом на нашем хвосте (`ys` - хвост и аккумулятор)
  -- наконец, нам нужно сохранить структуру, поэтому мы собираем это
  -- всё с помощью конструктора `(:)`
```

## Фантомные типы

Давайте заведем мнемонический тип `Hash`, который будет обёрткой над `String`. Скажем, что у нас есть класс типов `Hashable a` (у `a` есть род `Type`), у которого определена функция `hash`.

```haskell
newtype Hash = MkHash String

class Hashable a where
  hash :: a -> Hash
```

Закодируем некоторый `Int` как пару в наш хэш.

```haskell
hashPair :: Int -> Hash
hashPair n = hash (n, n)
```

Есть проблема, мы можем написать вот такое: `hashPair n = hash n`, что мы можем написать так, а не потребовать именно пару от нашего `hash`. Мы можем это проверить на уровне типов. Давайте добавим в наш `Hash` тип `a`, который *не будет никаким образом* использоваться.

```haskell
newtype Hash a = MkHash String

class Hashable a where
  hash :: a -> Hash a -- мы должны явно указать тип `a`

hashPair :: Int -> Hash (Int, Int) -- мы должны явно указать тип `a`
hashPair n = hash (n, n)
```

## Расширения

### `ScopedTypeVariables`

В качестве мотивации рассмотрим функцию `prepend2`, которая к существующему списку кладет в голову списка два одинаковых элемента.

```haskell
-- v0.0.0: компилируется
prepend2 :: Int -> [Int] -> [Int]
prepend2 x xs = pairFun x ++ xs 
  where pairFun y = [y, y]
```

Слишком громоздко, давайте немного упростим. Зачем нам вообще отдельная константа `y`, если мы знаем, что там точно будет `x`?

```haskell
-- v1.0.0: компилируется
prepend2 :: Int -> [Int] -> [Int]
prepend2 x xs = pair ++ xs 
  where pair = [x, x]
```

Скажем теперь, что функция `prepend2` может принимать не только `Int`, но и другой произвольный тип `a`.

```haskell
-- v2.0.0: ошибка компиляции
prepend2 :: a -> [a] -> [a]
prepend2 x xs = pair ++ xs 
  where pair = [x, x]
```

Внезапно, Haskell не может вывести тип, хотя, казалось бы, в top-level функции он определён (как `forall` по умолчанию). Попробуем исправить, указав явным образом, что у нас используется тип `a`.

```haskell
-- v3.0.0: ошибка компиляции
prepend2 :: a -> [a] -> [a]
prepend2 x xs = pair ++ xs 
  where pair :: [a]
        pair = [x, x] 
```

На этом этапе мы начинаем видеть достаточно понятную ошибку, выдаваемая компилятором. Исправим её, вернувшись к самому первому решению.

```haskell
-- v2.1.0: компилируется
prepend2 :: a -> [a] -> [a]
prepend2 x xs = pairFun x ++ xs 
  where pairFun :: a -> [a]
        pairFun y = [y, y] 
```

В чём проблема? По умолчанию, в видимости `where` не прокидываются `forall` нотации функции (`id :: a -> a` - это в точности `id :: forall a . a -> a`) внутрь. Поэтому, нам приходится подключать расширение, которая гласит, что мы можем использовать тот же тип из top-level функции (в том числе и в `where` блоке) тогда и только тогда, когда мы явно прописали ключевое слово `forall`.

```haskell
{-# LANGUAGE ScopedTypeVariables #-}

prepend2 :: forall a . a -> [a] -> [a]
prepend2 x xs = pair ++ xs 
  where 
    pair :: [a]  -- uses same type variable 'a'
    pair = [x, x] 
```

### `TypeApplications`

Часто бывает так, что мы хотим явным образом указать тот или иной тип у функции, если он выдаёт произвольный тип `b`, который должен быть вывести в зависимости от контекста. Однако, по умолчанию, мы не можем передать сам тип, в этом нам может помочь расширение.

```haskell
ghci> read "3"   :: Int
3
ghci> read "3.0" :: Double
3.0
-- без расширения

ghci> read @Int "3"
3
ghci> read @Double "3.0"
3.0
ghci> :t read @Int
read @Int :: String -> Int
-- с расширением
```

### `AllowAmbiguousTypes`

Когда мы вводим новый type-class `a`, в которой ни в одной из функции не использует тип `a`, возникает ошибка компиляции.

```haskell
class Size a where
  size :: Int

--  • Could not deduce (Size a)
--    from the context: Size a
--      bound by the type signature for:
--                 size :: forall a. Size a => Int
```

Исправить эту ошибку мы можем двумя способами: сказать, что функция `size` принимает тип `a`, но никак его не использует, либо воспользоваться расширением.

```haskell
{-# LANGUAGE AllowAmbiguousTypes #-}

class Size a where size :: Int
instance Size Int    where size = 8
instance Size Double where size = 16
```

Остается загадкой как нам получить число по некоторому из instance'ев типов? Воспользуемся предыдущем расширением.

```haskell
ghci> size @Double  -- -XTypeApplications
16
```
