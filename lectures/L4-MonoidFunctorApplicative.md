# Typeclasses

## Полугруппа и Моноид

Вспомним линейную алгебру. У нас есть некоторое замкнутое множество, на нем определены определенные ассоциативные бинарные операции. Такую структуру мы называем **полугруппой**.

Но поскольку мы работаем с типами, а не со множествами, потому мы можем определить в языке *type class* `Semigroup`, принимающая тип `m`, на которой определена операция, которая берет элементы типа `m` и возвращает `m` (это и есть *замкнутость* на типах).

```haskell
class Semigroup m where
  (<>) :: m -> m -> m
```

Для полугруппы определено свойство ассоциативности.

```haskell
(x <> y) <> z = x <> (y <> z)
```

В качестве примера из математики, обладающие свойством полугруппы можно привести функцию максимума/минимума.

В Haskell мы никаким образом не можем определить ту или иную верность операции на поставляемых свойствах структуры, потому ответственность за правильность работы лежит исключительно на программисте.

**Моноидом** мы называем полугруппу с определенным нейтральным элементом. В Haskell мы бы записали type-class `Monoid` как constraint `Semigroup`.

```haskell
class Semigroup m => Monoid m where
  mempty :: m
```

Для моноида определены ассоциативность и нейтральность элемента.

```haskell
x <> mempty = x
mempty <> x = x
```

Поскольку `Monoid` - это подкласс полугруппы `Semigroup`, для того, чтобы определить instance некоторого типа данных, необходимо определить instance полугруппы (чтобы для него был доступен оператор `(<>)`).

Примером моноида в Haskell можно привести тип списка, так как там есть ассоциативный оператор `(++)` и нейтральный элемент в виде пустого списка.

Посмотрим поглубже в type-class полугруппы.

```haskell
class Semigroup m where
  (<>)    :: m -> m -> m
  sconcat :: NonEmpty m -> m
  stimes  :: Integral b => b -> m -> m
```

Помимо `(<>)` у нас определены ещё две функции, обе сделаны через основной оператор:

* `sconcat` берёт *не пустой* список (то есть, тот, где есть хотя бы один элемент) и склепывает его по `(<>)`, то есть: `[a1, a2 .. an]` превращается в `a1 <> a2 <> .. <> an`
* `stimes` действует как *умножение*: мы хотим взять элемент `m` и сложить его с собой `b` раз, тогда: `stimes n x = x <> x <> ... <> x`

Рассмотрим instance для списков.

```haskell
instance Semigroup [a] where
  (<>) = (++) -- конкатенация двух списков
```

Возникает интересный вопрос по поводу полугрупп. Мы знаем, что `Int` также может являться полугруппой для операций умножения и сложения - но какой выбрать? Хотим иметь возможность использовать и то, и другое.

Легальный способ заиметь оба instance'а одновременно - это обернуть типы (`newtype`) над типом `a` (это может быть тот же `Int`) и для этих отдельных типов данных мы определяем instance полугруппы.

```haskell
newtype Sum a = Sum { getSum :: a }
newtype Product a = Product { getProduct :: a }
-- напоминание: { name :: type } - это именнованные поля,
-- на самом деле, это функция name :: Type type -> type
```

```haskell
instance Num a => Semigroup (Sum a) where
  Sum x <> Sum y = Sum (x + y)
  -- для того, чтобы мы смогли сложить,
  -- возникает constraint от нумерического типа

instance Num a => Semigroup (Product a) where
  Product x <> Product y = Product (x * y)
  -- для того, чтобы мы смогли умножить,
  -- возникает constraint от нумерического типа
```

Пример использования.

```haskell
ghci> 3 <> 5 :: Sum Int
Sum { getSum = 8 }

ghci> 3 <> 5 :: Product Int
Product { getProduct = 15 }
```

На самом деле, instance'ев полугруппы у нас бывает много, из-за свойств предлагаемых операций. Например,

```haskell
newtype Max a = Max { getMax :: a } -- max
newtype Min a = Max { getMin :: a } -- min
-- в этом случае, тип `a` должен быть instance от `Ord`

newtype Any = Any { getAny :: Bool } -- ||
newtype All = Any { getAll :: Bool } -- &&

newtype First a = First { getFirst :: Maybe a } -- first Just
-- `First` - обёртка под `Maybe`, которая возвращает первый `Just`
-- из цепочки `Maybe` применения `(<>)`
newtype Last a = Last { getLast :: Maybe a } -- last Just
-- `Last` - точно также с `First`, только возвращает последний `Just`
```

Посмотрим поглубже в type-class моноида.

```haskell
class Semigroup m => Monoid m where
  mempty  :: a
  mappend :: a -> a -> a
  mconcat :: [a] -> a
```

У нас появляются ещё две функции:

* `mappend` - по умолчанию (то есть, его не нужно снова прописывать именно для моноида), это - оператор `(<>)`
* `mconcat` - похож на `sconcat`, только список *может быть пустым* - разница в том, что если в `mconcat` мы подаем пустой список, то получаем нейтральный элемент `mempty`

Рассмотрим instance для списков.

```haskell
instance Monoid [a] where
  mempty = [] -- конкатенация списка с пустым даст тот же список
  mappend l1 l2 = l1 ++ l2 -- можно не писать, так как это - `(<>)`
```

Можно также создать моноид пары только в том случае, если каждый элемент в ней - это моноид.

```haskell
instance (Monoid a, Monoid b) => Monoid (a, b) where
  mempty = (mempty, mempty)
  mappend (a1, b1) (a2, b2) = (mappend a1 a2, mappend b1 b2)
```

## Свёртка

В этой части мы будем рассматривать две функции `foldr` и `foldl` - суть их почти одинакова, первое - это правая свёртка, второе - левая. На самом деле, `foldr` - это, так называемый, *элиминатор списка*.

**Элиминатор** - функция, которая преобразует некоторый алгебраический тип `a` в произвольный тип `b`.

Попробуем вывести тип функции `foldr`.

1. У нас есть тип `List`, определенный следующим образом:

    ```haskell
    data List a = Nil | Cons (List a)
    ```

2. `Nil` имеет тип `List a` - мы хотим его преобразовать в `b`:

    ```haskell
    Nil :: List a ~~>> b
    ```

3. Далее, у нас есть `Cons` имеет тип `a -> List a -> List a` - также хотим его преобразовать в `b`:

    ```haskell
    Cons :: a -> List a -> List a ~~>> a -> b -> b
    ```

4. Наконец, поскольку у `List` есть два конструктора, необходимо их совместить как элиминатор нашего списка:

    ```haskell
    listElim :: [a] -> b
    ```

    Внимание: у списка *два* конструктора, каждому из них сопоставляется типы `b` и `a -> b -> b` преобразованные, и они записываются в качестве аргументов

    ```haskell
    listElim :: (a -> b -> b) -> b -> [a] -> b
    ```

Мы вывели тип так называемой *правой свёртки* (`foldr`) по переданной бинарной функции преобразования и стартовому значению свёртки следующим образом:

> поставить картинку

Здесь - вместо условного `Cons` мы подставляем функцию `f`, вместо конца списка (`Nil`) - `z`.

*Левая свёртка* (`foldl`) очень похожа на правую.

> поставить картинку

Однако, тут мы конструируем цепочки применения левоассоциативно (поэтому, `b -> a -> b`).

Для элиминатора списка существует обобщение в виде элиминатора нечто...

```haskell
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b
```

Для того, чтобы понять, что такое `t a`, где у `t` есть constraint `Foldable` нам нужно поглубже посмотреть на типы. Мы знаем, что у любого значения есть тип:

```haskell
ghci> :t True
True :: Bool
```

Где `Bool` - это логический *тип*. Можно ли продолжить цепочку? Можно.

```haskell
ghci> :k Bool
Bool :: Type
```

Вроде бы логично, но почему `:k`? Потому что *тип типа*, с точки зрения теории, называется **родом** (или: **kind**).

Тогда, для `Int` родом будет также являться `Type`. Такая же ситуация с `Maybe Int` - его род это тот же `Type`. А какой kind у `Maybe`? Посмотрим внимательно на `Maybe`: он принимает тип, а тип `Int` явно является `Maybe Int` тем самым принимаемым типом, но тогда наш `Maybe` принимает тип и возвращает тип.

```haskell
ghci> :k Maybe Int
Maybe Int :: Type

ghci> :k Maybe
Maybe :: Type -> Type
```

Получаем функции на типах. Посмотрим теперь на `Either () Char` - его род, очевидно, это `Type`. А просто `Either ()`? Как и с `Maybe`: `Either () :: Type -> Type`. Наконец, какой род у `Either`? `Type -> Type -> Type`.

```haskell
ghci> :k Either () Char
Either () Char :: Type

ghci> :k Either ()
Either () :: Type -> Type

ghci> :k Either
Either :: Type -> Type -> Type
```

Зададим `IdentityT` следующим образом и сразу посмотрим на его род.

```haskell
ghci> data IdentityT m a = IdentityT (m a)
ghci> :k IdentityT
IdentityT :: forall {k}. (k -> Type) -> k -> Type
```

Посмотрим на определение `IdentityT`: тут тип `m` принимает `a`, тогда `m` должен быть типом так называемым *типом высшего рода* (так как он принимает другой тип). Более того, `a` - это какой-то произвольный тип `k`, тогда `m` - это тип, род которого `k -> Type` - почему обязательно в `Type` - потому что по умолчанию все `data` возвращают `Type`.

Рассмотрим теперь род у класса `Num`.

```haskell
ghci> :k Num
Num :: Type -> Constraint
```

Он принимает `Type`, так как сам класс `Num` принимает тип `a`, а возвращает `Constraint` - это также тип, но про него будет позже.

Наконец, посмотрим на род `Foldable`.

```haskell
ghci> :k Foldable
Foldable :: (Type -> Type) -> Constraint
```

Он принимает `(Type -> Type)`, так как это *контейнер*, и возвращает `Constraint`, так как он - `class`.

Вернемся к свёрткам, а именно приведем пример использования правой свёртки: `foldr (*) 3 [2, 1, 10]`. Его начальное значение (то есть, `z` из картинки выше) - это `3`, тогда данный вызов развернётся в: `2 * 1 * 10 * 3`.

```haskell
ghci> foldr (*) 3 [2, 1, 10]
60
```

Посмотрим глубже на класс `Foldable`. Минимальный и простой вариант состоит из нескольких функций.

```haskell
class Foldable t where
  fold :: Monoid m => t m -> m -- эквивалентно `foldMap id`
  foldMap :: Monoid m => (a -> m) -> t a -> m
  foldr :: (a -> b -> b) -> b -> t a -> b
```

Здесь интересен `foldMap`: он берёт контейнер (или: *контекст*), возвращает моноид и в качестве первого аргумента мы берем функцию, которая умеет трансформировать элемент контейнера в моноид.

Рассмотрим instance `Foldable` для списка.

```haskell
instance Foldable [] where
  foldr :: (a -> b -> b) -> b -> [a] -> b
  foldr _ z [] = z
  foldr f z (x:xs) = f x (foldr f z xs)
```

Мы получили буквально рассмотренный ранее элиминатор списка:

* на пустом списке мы возвращаем стартовое значение (или: аккумулятор)
* на непустом применяем `f` в голове и рекурсивно вызываемся на хвосте

Рассмотрим instance `Foldable` для типа `Maybe`.

```haskell
instance Foldable Maybe where
  foldr :: (a -> b -> b) -> b -> Maybe a -> b
  foldr _ z Nothing = z
  foldr f z (Just x) = f x z
```

Определили свёртку следующим образом, мы:

* либо возвращаем наш аккумулятор (ничего не делаем) на `Nothing`
* либо, если есть значение, применяем функцию и возвращаем новое значение

## Functor

Рассмотрим простой случай применения функции к некоторому значения: например, к `2` прилетает `(+3)` и мы честно получаем `5`, так как мы просто будем иметь выражение в виде `3 + 2`. А теперь представим, что значение `2` спрятано где-то в контейнере/контексте и просто так применить функцию сложения будет не просто (банально потому, что мы не можем определить оператор сложения между числовым и внезапной `data`). Тогда мы захотели бы волшебную функцию `fmap`, которая смогла бы пропихнуть функцию `(+3)` и изменить значение внутри контекста, **при этом**, не меняя сам контекст.

В качестве контекста можно привести `Maybe`.

```haskell
ghci> fmap (+3) (Just 2)
Just 5

ghci> fmap (+3) Nothing
Nothing
```

В общем случае, мы имеем тип `f`, чей род это `Type -> Type`, который и является тем самым контекстом.

```haskell
class Functor f where
  fmap :: (a -> b) -> f a -> f b
  -- мы принимаем унарную функцию и возвращаем функцию, которая
  -- возвращает контекст
```

У класса `Functor` имеются два основных правила, из-за которых он является **левоморфизмом**:

1. `fmap id` - эквивалентно `id`
2. `fmap (f . g)` эквивалентно `fmap f . fmap g`

Рассмотрим instance `Functor` для типа `Maybe`.

```haskell
instance Functor Maybe where
  fmap :: (a -> b) -> Maybe a -> Maybe b
  fmap f (Just x) = Just (f x)
  -- у нас есть значение - применим на него функцию и не потеряем
  -- контекст `Just`
  fmap _ Nothing  = Nothing
```

Подобно оператору `($)` существует левоассоциативный оператор `(<$>)`, который применяет `fmap`, для упрощения записи.

```haskell
infixl 4 <$>
(<$>) :: Functor f => (a -> b) -> f a -> f b
(<$>) = fmap
```

Рассмотрим instance `Functor` для списка.

```haskell
instance Functor [] where
  fmap :: (a -> b) -> [a] -> [b]
  fmap = map
  -- пропихиваем функцию к каждому элементу из списка
```

На самом деле, функция (то есть, оператор `(->)`) также является типом данных, они принимает аргумент (первый тип) и результат (второй тип). Поэтому, у самой по себе функции родом будет `Type -> Type -> Type`. Если мы применим к стрелке один аргумент, например, `Int`:

```haskell
ghci> :k (->) Int
(->) Int :: Type -> Type
```

Заметим, что такой kind - `Type -> Type` - подходит для instance'а `Functor`.

```haskell
instance Function ((->), r) where
  fmap :: (a -> b) -> (r -> a) -> r -> b
  fmap = (.) -- композиция двух функций `f` и `g`
```

## Applicative Functor

У нас есть функции `a -> b`, где `b` - произвольный тип, и вместо значения мы можем легко подставить любую другую функцию и получить `a -> (b -> c)`. Например, здесь функцию `(*)` имеет тип как бинарная функция `a -> a -> a`, мы здесь ещё применяем на `Just` и получаем `Just` от функции:

```haskell
ghci> fmap (*) (Just 3) == Just (3 *)
-- Just (Int -> Int)

ghci> :t fmap (++) (Just "hey")
fmap (++) (Just "hey") :: Maybe ([Char] -> [Char])

ghci> :t fmap compare (Just 'a')
fmap compare (Just 'a') :: Maybe (Char -> Ordering)
```

В чем проблема? В том, что в какой-то момент у нас возникнет `Just (a -> b)` - и как нам применять `fmap` - непонятно.
