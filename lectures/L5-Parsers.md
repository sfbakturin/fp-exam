# Комбинаторы парсеров

## Введение

**Парсинг** - это процесс конвертации плохо структурированных данных (байтов или символов) в строгую структуру данных (типы данных).

Идея комбинаторных парсеров в том, что мы сначала построим маленькие, мелкие части (как бы атомарные части), а из них мы будем строить уже что-то большое и осмысленное.

Определимся с типом возвращаемых значений для парсера, в случае, если мы хотим что-то спарсить. Например, опишем для парсинга целого числа `Integer`.

```haskell
parseInteger :: String -> Maybe (Integer, String)
```

Мы принимаем строку и возвращаем возможное значение пары от `Integer` (собственной персоны значение, которое мы смогли спарсить) и `String` (оставшаяся часть для продолжения последующего парсинга). Если произошла ошибка, то мы вернём `Nothing`.

Ну и давайте обобщим данную функцию на новый тип, для которого мы потом определим instance'ы.

```haskell
newtype Parser a = Parser { runP :: String -> Maybe (a, String) }
-- `a` - тип возвращаемого значения после парсинга
-- `String` (аргумент) - входной поток символов
-- `Maybe` - флаг ошибки (произошла или нет)
-- `(a, String)` - возвращаемое значение и оставшийся выходной поток символов  
```

Конечной цели мы добиваемся следующей: `runP` запускает поданный парсер на данной строке и возвращает что-то.

```haskell
parseInteger :: Parser Integer
-- функция парсинга с данным типом возврата значения
```

```haskell
runP :: Parser a -> String -> Maybe (a, String)
```

```haskell
ghci> runP parseInteger "5"
Just (5, "") :: Maybe (Integer, String)

ghci> runP parseInteger "42x7"
Just (42, "x7") :: Maybe (Integer, String)

ghci> runP parseInteger "abc"
Nothing :: Maybe (Integer, String)
```

## Реализация

Перейдем к реализации, а именно к будущим instance'ам типа `Parser`: всего их будет несколько штук и они опираются на [`Functor`, `Applicative`, `Alternative`](L4-MonoidFunctorApplicative.md) и [`Monad`](L5-Monads.md). Рассмотрим, что каждый из них будет делать и означать.

```haskell
instance Functor Parser
-- позволит нам как-то менять полученное после парсинга значение
```

```haskell
instance Applicative Parser
-- позволит нам запускать парсеры одни за другим последовательно
```

```haskell
instance Monad Parser
-- позволит делать тоже самое, что и вышеописанное,
-- но с монадическими особенностями (например, парсить, беря в контекст значение)
```

```haskell
instance Alternative Parser
-- позволит нам выбирать тот или иной удачный в парсинге парсер
-- обычно, выбирают первый успешный, отбрасывая все остальные
```

### Примитивные парсеры

Итак, начнём с парсера, который ничего не делает - всегда заканчивается успешно.

```haskell
ok :: Parser ()
ok = Parser (\s -> Just ((), s))
-- возвращаем парсер, который
--   1. берёт на вход строку
--   2. возвращает в качестве значения `Unit`
--   3. возвращает всю строку как остаточная строка
```

Заметим, что он всегда завершается успешно, так как он ничего не делает со строкой. А теперь что-то посложнее: создадим парсер, который выдаёт ошибку, если поданный парсер завершился успешно и наоборот.

```haskell
isnot :: Parser a -> Parser ()
isnot parser = Parser $ \s -> case runP parser s of
                                    Just _  -> Nothing
                                    Nothing -> Just ((), s)
-- мы принимаем на вход `parser`, который, если вернётся с ошибкой,
-- то мы завершимся успешно, в ином случае - вернёмся с ошибкой
-- мы создаем парсер, который принимает на вход строку (`\s`) и:
--  1. запускает на этой строке поданный парсер (`runP parser s`)
--  2. проверяет на возвращаемое значение:
--  2.1. если `Nothing`, значит завершился с ошибкой, возвращаем пустоту с строкой
--  2.2. если `Just`, значит успех, возвращаем `Nothing` - как ошибку
```

И ещё один уже более реальный парсер: тот, который завершается успешно, если нам подали пустую строку (или: конец потока).

```haskell
eof :: Parser ()
eof = Parser $ \s -> case s of
                      [] -> Just ((), "")
                      _  -> Nothing
-- Если в парсер подали пустую строку (String - это [Char]), тогда мы
-- возвращаем `Just` как успешный парсинг строки на значение, в ином случае, если
-- мы не смогли в pattern matching (то есть, не пустая строка), возвращаем Nothing
-- как ошибку
```

Наконец, что-то осмысленное: парсер на проверку на ожидаемый символ. Если входной поток начинается с ожидаемого символа, тогда возвращаем значение и остаточный поток, иначе - ошибка.

```haskell
satisfy :: (Char -> Bool) -> Parser Char
satisfy p = Parser $ \s -> case s of
                            []     -> Nothing
                            (x:xs) -> if p x then Just (x, xs) else Nothing
-- принимаем на вход предикат, по которому мы будем ориентироваться, допустить
-- или не допускать такой поток
-- в парсере мы принимаем строку и сразу же проверяем не пуста ли она, если пуста,
-- тогда возвращаем ошибку (так как мы ожидаем не пустой символ), иначе, проверяем
-- первый символ на предикат: `True`, значит возвращаем как успешный парсинг, иначе
-- возвращаем `Nothing` - как ошибку
```

### Комбинация примитивных парсеров

Начнем комбинировать вышеописанные парсеры во что-то используемое. Начнём с того, что всегда заканчивается неуспехом при любом входном значении.

```haskell
notok :: Parser ()
notok = isnot ok
-- попарсимся парсером `ok`, который ничего не делает и всегда вернёт успех
-- закинем его результат в `isnot`, который требует, чтобы не было успеха
-- получаем "невозможный" случай или bottom
```

Создадим также парсер для проверки одного символа на ожидаемый. Для этого мы применим частично `(==)` с элементом, который мы ожидаем, и поддадим в парсер `satisfy`.

```haskell
char :: Char -> Parser Char
char c = satisfy (== c)
```

Наверняка, мы захотим также потребовать, чтобы символ обязательно был из семейства "цифра". Можем использовать уже готовую функцию в качестве предиката.

```haskell
digit :: Parser Char
digit = satisfy isDigit
```

Или захотим вообще любой символ принять - давайте примем как `(\ch -> True)`.

```haskell
anyChar :: Parser Char
anyChar = satisfy (const True)
```

Примеры использования данных комбинаторов.

```haskell
ghci> runP eof ""
Just ((),"")

ghci> runP eof "aba"
Nothing

ghci> runP (char 'a') "aba"
Just ('a',"ba")

ghci> runP (char 'x') "aba"
Nothing
```

### Комбинация большей власти

А теперь, на основе мелких вышеописанных парсеров, мы опишем `Functor`, `Applicative`, `Monad` и `Alternative` нашего `Parser`'а. Напомним, что его тип - `Parser a = Parser { runP :: String -> Maybe (a, String) }`.

```haskell
instance Functor Parser where
  fmap :: (a -> b) -> Parser a -> Parser b
  fmap f (Parser parser) = Parser (fmap (fst . f) . parser)
  -- нам дают некоторый парсер с типом `a`, мы хотим изменить его значение на
  -- другой тип `b`, для этого мы пропихиваем внутрь парсера функцию для
  -- извлечения первого элемента пары и применения функции `f`, поскольку у нас
  -- используется `Maybe` - воспользуемся его `fmap`'ом
```

```haskell
instance Applicative Parser where
  pure :: a -> Parser a
  pure a = Parser $ \s -> Just (a, s)
  -- берем новое значение и заворачиваем его в новый парсер-контекст,
  -- который ничего не делает (в данном случае)

  (<*>) :: Parser (a -> b) -> Parser a -> Parser b
  Parser pf <*> Parser pa = Parser $ \s -> case pf s of
      Nothing     -> Nothing
      Just (f, t) -> case pa t of
          Nothing     -> Nothing
          Just (a, r) -> Just (f a, r)
  -- сначала "извлекаем" всё из парсера `Parser (a -> b)` через применение его
  -- на некоторой поданной строке `s`, его результатом служит либо `Nothing`,
  -- тогда, выходим с ошибкой, либо `(f, t)` - запускаем парсер `Parser a` на
  -- остаточной строке и далее применяем функцию `f`, если успешно, иначе,
  -- возвращаем `Nothing` - как ошибка
```

```haskell
instance Monad Parser
-- аналогично как и с `Applicative`: множество `case`'ов
```

```haskell
instance Alternative Parser where
  empty :: Parser a
  -- договоримся, что эта `empty` возвращает парсер, который всегда падает
  -- можно воспользоваться `notok`

  (<|>) :: Parser a -> Parser a -> Parser a
  -- запускаем первый, если он закончился неудачно, запускаем второй
  -- иначе, ничего более не делаем
```

### Итоги реализации

Итого, мы имеем следующий набор наборов функций и операторов для комбинации комбинаторов.

```haskell
-- Тип парсера.
newtype Parser a = Parser { runP :: String -> Maybe (a, String) }
```

```haskell
-- Примитивные (или атомарные) парсеры.
eof, ok :: Parser ()
satisfy :: (Char -> Bool) -> Parser Char
```

```haskell
-- Функторные комбинаторы для изменения значения после парсинга.
fmap  :: (a -> b) -> Parser a -> Parser b
(<$)  :: a -> Parser b -> Parser a
```

```haskell
-- Аппликативные парсеры.
pure  :: a -> Parser a
-- возвращает новый парсер
(<*>) :: Parser (a -> b) -> Parser a -> Parser b
-- последовательный запуск парсеров
(<*)  :: Parser a -> Parser b -> Parser a
-- запускает оба, но возвращает результат первого
(*>)  :: Parser a -> Parser b -> Parser b
-- запускает оба, но возвращает результат второго
```

```haskell
-- Альтернативные парсеры.
empty :: Parser a
-- парсер, который всегда заканчивается неудачно
(<|>) :: Parser a -> Parser a -> Parser a
-- выбор парсера, `orElse`
many  :: Parser a -> Parser [a]
-- спарсить ноль или много раз парсером
some  :: Parser a -> Parser [a]
-- спарсить один или много раз парсером
```

```haskell
-- Монадический парсер.
(>>=) :: Parser a -> (a -> Parser b) -> Parser b
-- парсер `andThen`
```

### Примеры

#### Небольшие простые примеры

Приведем несколько простых примеров использования комбинаторов.

```haskell
ghci> runP (ord <$> char 'A') "A"
Just (65,"")
-- парсер, который требует на вход 'A' и переводит его в `Int`
```

```haskell
ghci> runP ((\x y -> [x, y]) <$> char 'a' <*> char 'b') "abc"
Just ("ab","c")
ghci> runP ((\x y -> [x, y]) <$> char 'a' <*> char 'b') "xxx"
Nothing
-- парсер, который требует на вход 'a', 'b' и переведёт это в строчку (список)
```

```haskell
ghci> runP (char 'a' <* eof) "a"
Just ('a',"")
ghci> runP (char 'a' <* eof) "ab"
Nothing
-- парсер, который требует на вход 'a' и обязательно законченный поток символов
```

```haskell
ghci> runP (many $ char 'a') "aaabcd"
Just ("aaa","bcd")
ghci> runP (many $ char 'a') "xxx"
Just ("","xxx")
-- парсер, который требует ноль или много символов 'a'
```

```haskell
ghci> runP (some $ char 'a') "xxx"
Nothing
-- парсер, который требует один или много символов 'a'
```

```haskell
ghci> runP (char 'a' <|> char 'b') "abc"
Just ('a',"bc")
ghci> runP (char 'a' <|> char 'b') "bca"
Just ('b',"ca")
ghci> runP (char 'a' <|> char 'b') "cab"
Nothing
-- парсер, который или требует на вход 'a', или 'b'
```

#### Реалистичный пример

Среди парсеров есть две полезные функции, объединяющие `char`, `<$>`, которые нужны уже для парсинга целых строк.

```haskell
string :: String -> Parser String
-- требует на вход конкретную строчку
oneOf  :: [String] -> Parser String
-- требует на вход какой-то из поданных строк, возвращает на первом получившемся
```

Теперь научимся парсить `yes`/`no` ответ от пользователя, причем в разных вариациях слов. Для этого, нам понадобится условный "enum", парсер, который парсит `"yes"` и парсер, который парсит `"no"`.

```haskell
data Answer = Yes | No
-- условный enum для ответа
```

```haskell
yesP :: Parser Answer
yesP = Yes <$ oneOf ["y", "Y", "yes", "Yes", "ys"]
-- парсер, который парсит один из нескольких вариантов строки "yes"
```

```haskell
noP :: Parser Answer
noP = No <$ oneOf ["n", "N", "no", "No"]
-- парсер, который парсит один из нескольких вариантов строки "no"
```

```haskell
answerP :: Parser Answer
answerP = yesP <|> noP
-- объединим веселье предыдущих
-- попробуем спарсить "yes", получилось - возвращаем Yes
-- иначе, пробуем - "no", получилось - No, иначе - ошибка
```
