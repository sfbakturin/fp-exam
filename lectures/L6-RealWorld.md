# RealWorld

## `getchar`

Попробуем создать функцию получения одного символа из некоторого места. Мы не будем передавать его в саму функцию, хотя, очевидно, что так нельзя сделать, ибо у нас в Haskell нету ничего глобального (что уже является проблемой).

```haskell
getchar :: Char
getchar = -- implementation defined --

get2chars :: [Char]
get2chars = [getchar, getchar]
```

Допустим, мы это смогли сделать. Что ещё проблемно?

1. Поскольку функции по типам чистые, то модель вычисления может в теории лишь посчитать один раз получить `getchar` и переиспользовать это значение.
2. Даже если это (1) не так, никто не гарантирует, что наша последовательность вызовов для получения символов будет совпадать с ожидаемым.

Для начала решим первую проблему. Давайте введем для `getchar` ещё один параметр-счётчик. Внутри `getchar` мы не будем его использовать, однако вызов функции с разными числами уже даст гарантию на устранение проблемы с одинаковыми значениями.

Теперь решим вторую проблему. Пусть `getchar` будет возвращать не `Char`, а `(Char, Int)`, где второе значение - это измененный переданный ему счётчик. Тогда, после возврата некого `i'` мы переиспользуем его как номер вызова следующего `getchar`.

```haskell
getchar :: Int -> (Char, Int)
getchar = -- implementation defined --

get2chars :: Int -> [Char]
get2chars i = [a, b]
  where
    (a, i1) = getchar i
    (b, i2) = getchar i1
```

Теперь всё точно работает. Но в чём ещё проблема? В расширяемости: если мы захотим создать функцию `get4chars`, то нам придётся проделать те же махинации, только вызывать теперь `get2chars` и потребовать, чтобы тот возвращал такую же пару.

## `RealWorld` и реальный мир

Представим себе игрушечный тип `IO a` в следующем виде: мы берём наш внешний мир, проводим с ним какие-то махинации и возвращаем в виде пары значения `a` и нового, измененного состояния внешнего мира.

```haskell
type IO a = RealWorld -> (a, RealWorld)
```

Заметим, что такая форма записи очень легко становится сильно общим случаем для вышеописанного паттерна в виде значения+указатель-на-изменения. По умолчанию, функцию входа в программу имеет сигнатуру в виде `main :: IO ()` - если раскрыть по нашем типу  `main :: RealWorld -> ((), RealWorld)`, то есть, мы ничего не вернули, но мир вокруг нас поменялся.

Предположим, что мы смогли как-то реализовать `RealWorld` и написали вот такую программу.

```haskell
getChar :: RealWorld -> (Char, RealWorld)
getChar = -- implementation defined --

main :: RealWorld -> ((), RealWorld)
main w0 = do
  let (a, w1) = getChar w0
      (b, w2) = getChar w2
  in ((), w2)
```

Правда ли, что компилятор может пропустить вызовы `getChar`? Нет, так как мы явно пропихиваем в функции разные объекты. Правда ли, что компилятор может поменять местами вызовы `getChar`? Нет, так как у нас следующее состояние мира зависит от предыдущего. Наконец, можем ли мы заиметь дублирующийся вызовы `getChar`? Также нет, так как каждый раз мы используем разные `RealWorld` объекты (банально, двигаемся с указателем).

Немного заглянем поглубже и посмотрим, как на самом деле выглядит тип `IO`. В стандартной библиотеке вы сможете найти вот такой тип.

```haskell
newtype IO a = IO  { unIO :: State# RealWorld -> (State# RealWorld, a) }
```

Здесь сразу стоит отметить, что `State#` - это не тот, который был про монады. Символ решётки в названии говорит о том, по декларации языка, что данный тип или класс используется в низкоуровневых вещах (например, он может быть связан с Си-шным кодом для вызова `fopen`). Если взглянуть повнимательнее на функцию `unIO`, то мы увидим, что это - почти в точности [реализованный `State`](L5-Monads.md). Для `IO` определён instance от монады.

```haskell
instance Monad IO where
  IO m >>= k = IO (\s -> 
     case m s of 
       (newS, a) -> unIO (k a) newS)


  return x = IO (\s -> (s, x))
  -- стандартно заворачиваем в состояние, которое мы никак не меняем,
  -- также не меняем и все другие состояния
```

## `do`-нотация

Из [монад](L5-Monads.md) мы помним про оператор `(>>)`, который, как мы знаем, имел некоторый эффект - его результат нам не был важен, но он мог повлиять. Для удобства мы ограничимся только этим вариантом оператора.

```haskell
(>>) :: IO a -> IO b -> IO b
```

Для чего нужна `do`-нотация? По большей части она нужна для удобства написания а-ля императивного кода на Haskell: когда мы прописываем действия один за другим. В этом нам всё ещё может помочь оператор `(>>)`, поскольку он для `IO` гарантирует порядок исполнения через вставки в виде `let`-`in`. Грубо говоря, вот такой кусочек кода: `(action1 >> action2) world0` полностью эквивалентен:

```haskell
let (_, world1) = action1 world0
    (b, world2) = action2 world1 -- одно зависит от другого, поэтому
in (b, world2)                   -- пропусков или swap'ов быть не должно
```

В этом нам также может помочь и `do`-нотация.

```haskell
main :: IO ()
main = do putStrLn "What is your name?"
          putStrLn "How old are you?"
          putStrLn "Nice day!"

-- полностью эквивалентно --

main :: IO ()
main = putStrLn "What is your name?" >>
       putStrLn "How old are you?"   >>
       putStrLn "Nice day!"
```

Представим, что у нас есть список действий, которые мы бы хотели исполнить, причем не вызывая каждую из них по отдельности. Для таких случаев была придумана функция `sequence_`, которая берет список `IO a` и возвращает `IO ()`, исполняя каждую из действий в том порядке, в которой была задана последовательность.

```haskell
sequence_ :: [IO a] -> IO ()
sequence_ []     = return ()
sequence_ (x:xs) = x >> sequence_ xs
```

Также вспомним и про bind оператор. Если рассматривать его специализацию в виде `IO a`, то мы также можем гарантировать, что все действия будут выполнены по порядку из-за развёртки и в `let`-`in` выражения. Грубо говоря, такая строчка - `(action1 >>= action2) world0` - будет развернута в

```haskell
let (a, world1) = action1 world0
    (b, world2) = action2 a world1
in (b, world2)
```

Теперь, представим себе функцию из стандартной библиотеки `getLine :: IO String`, она считывает с стандартного ввода в виде строки и возвращает, внимание, IO-объект. Очевидно, мы не сможем написать вот такое: `let s = getLine`, для таких случаев был создан новый оператор вида `(<-)`, который мы можем также использовать, чтобы код казался менее изощренным.

```haskell
main :: IO ()
main = do
  s <- getLine
  putStrLn s
```

Как и `let`-`in` после `s <- getLine` нам ниже по коду доступен данный индификатор как переменная. На самом деле, это также является синтаксическим сахаром. Данный оператор можно раскрыть в bind, который далее прокидывает свой аргумент дальше, в данном случае, - это `putStrLn`.

```haskell
main :: IO ()
main = do
  getLine >>= \s -> putStrLn s
```

## `return`

Как уже было сказано ранее, поскольку `IO` является монадическим типом, то `return` будет заворачивать нам некоторый объект в `IO` контекст. Допустим, мы захотим функцию, которая бы считывала бы с консоли и возвращала строчку как развернутую. Приведем пример оной и использование.

```haskell
getReversedLine :: IO String
getReversedLine = do
  s <- getLine
  -- прочитали с консоли, у индификатора `s` тип `String` (!)
  return (reverse s)
  -- развернули строку `reverse s` получили объект типа `String` (!)
  -- но мы возвращаем `IO` (контекст), а значит завернём его, используя `return`

main :: IO ()
main = do
  s <- getReversedLine
  putStrLn s
```

**Важно**: не следует путать `return` здесь, с любым другим таким же оператором в любом другом языке программирования - мы не прерываем *действия контекста* функции, мы *запаковываем нечто* в `IO`-контекст.

## Ленивое IO

Представим себе небольшую программу, которая бы читала из файла `foo.txt`, дописывала в начало символ `'a'`, записывала бы обновленный контент в `bar.txt`, а затем мы бы прочитали `bar.txt` и вывели на экран.

```haskell
main :: IO ()
main = do
  fileContent <- readFile "foo.txt"
  writeFile "bar.txt" ('a':fileContent)
  readFile "bar.txt" >>= putStrLn
```

По модулю присутствия файлов `foo.txt` и `bar.txt` и прав пользовательского кода на открытие этих файлов, данный код абсолютно безопасен и ничем не примечателен. Но теперь сделаем небольшое изменение: зачем нам писать в какой-то другой файл, если мы можем написать в тот же файл?

```haskell
main :: IO ()
main = do
  fileContent <- readFile "foo.txt"
  writeFile "foo.txt" ('a':fileContent)
  readFile "foo.txt" >>= putStrLn
```

Внезапно, но такой код выдаст исключение: ресурс, а именно файловый дескриптор `foo.txt`, занят другим потоком. Вспоминаем про Haskell: он настолько ленив, что даже работа с критическими дескрипторами может быть ленива и опасна. И действительно: `readFile` по документации - это `LazyIO`, в данном случае `fileContent` - это просто привязка и не более, данный индификатор не владеет ресурсами. С другой стороны, если бы мы хоть что-нибудь сделали с `fileContent` (если вывести, например), то дальнейшая перезапись файла будет безопасным.
