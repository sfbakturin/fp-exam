# Ускорение Haskell

## `DList`

Рассмотрим довольно медленную операцию в Haskell - конкатенация списков - само это действие долгое и тяжелое по причине неизменяемости объектов (приходится копировать). Однако, даже здесь можно сделать ещё хуже скорость. Представим себе функцию `trinity`, которая бы конкатенировала три списка в один.

```haskell
trinity :: [a] -> [a] -> [a] -> [a]
trinity a b c = a ++ b ++ c   -- (1)
trinity a b c = a ++ (b ++ c) -- (2)
trinity a b c = (a ++ b) ++ c -- (3)
```

Вопрос, какой из подход хуже по скорости и памяти? Мы помним, что `(++)` имеет правую ассоциацию, а значит варианты (1) и (2) полностью эквивалентны. Хуже всех (3): потому что мы хотим к более короткому присоединять, так как у последнего нам нужно обновить ссылку на следующую ноду последнего узла. Посмотрим повнимательнее на оператор `(++)`.

```haskell
infixr 5 ++
(++) :: [a] -> [a] -> [a]
[]     ++ b = b
(x:xs) ++ b = x : (xs ++ b) -- конструктор `:`
```

Не забываем, что у нас все вычисления ленивы, а значит мы проходимся только по первому аргументу (второй может быть бесконечным) с pattern-matching. Более понятный пример.

```haskell
a = [1..n] ++ ([1..m] ++ [1..k]) -- сначала конкатенируем то, что в скобках
  = [1..n] ++ [1..m, 1..k]       -- получили O(m) операций
  = [1..n, 1..m, 1..k]           -- получили O(n) операций
                                 -- итого O(n + m)
```

```haskell
b = ([1..n] ++ [1..m]) ++ [1..k] -- сначала конкатенируем то, что в скобках
  = [1..n, 1..m] ++ [1..k]       -- получили O(n) операций
  = [1..n, 1..m, 1..k]           -- получили O(n + m) операций
                                 -- итого O(2 * n + m) операций
```

Нам приходится слишком много думать о том, как правильно расставить скобки, а хотелось бы иметь волшебный тип, который бы сам умел "расставлять" правильным образом скобки. В этом нам поможет *Difference List* или `DList`. Выглядит этот зверь следующим образом.

```haskell
newtype DList a = DL { unDL :: [a] -> [a] }
```

Для него определены две и ещё одна по определению операции: `fromList`, `toList` и `append`.

```haskell
fromList :: [a] -> DList a
fromList l = DL (l++)
-- принимает список и возвращает обёртку `DList`
-- обратим внимание на `(l++)` - это правая связка, а значит,
-- `(l++)` раскрывается в `(\l' -> l ++ l')`

toList :: DList a -> [a]
toList (DL lf) = lf []
-- принимаем обёртку `DList` и возвращаем список
-- по определению `fromList`, `toList` - это `l ++ []`
-- сохраняется свойство моноида: нейтральный элемент

append :: DList a -> DList a -> DList a
append (DL f) (DL g) = DL (\xs -> f (g xd))
-- принимаем две обёртки и возвращаем новую конкатенацию
-- замечаем, что сохраняется свойство полугруппы: (a <> b) <> c == a <> (b <> c)
```

А теперь поймем, почему же это лучше, чем список (казалось бы, мы добавляем слева `l`). Рассмотрим два случая: `(f <> g) <> h` и `f <> (g <> h)` - раскрыв в виде объектов и скобки (как операция `append`) мы обнаружим, что эти обе операции, во первых, одинаковы, а во вторых выводят последнюю конкатенацию в виде ожидаемой: `f' ++ (g' ++ (h' ++ ...))` - а этот случай, как уже разбиралось ранее, намного лучше, чем `(((f' ++ g') ++ h') ++ ...)`.

```haskell
DL f <> (DL g <> DL h) ≡ DL f <> DL (\xs -> g (h xs)) 
                       ≡ DL f <> DL (\xs -> g' ++ (h' ++ xs))  -- t ≡ (\xs -> ...)
                       ≡ DL f <> DL t
                       ≡ DL $ \ys -> f (t ys)
                       ≡ DL $ \ys -> f' ++ (t ys)
                       ≡ DL $ \ys -> f' ++ (g' ++ (h' ++ ys))
```

```haskell
(DL f <> DL g) <> DL h ≡ DL (\xs -> f (g xs)) <> DL h 
                       ≡ DL (\xs -> f' ++ (g' ++ xs)) <> DL h  -- t ≡ (\xs -> ...)
                       ≡ DL t <> DL h
                       ≡ DL $ \ys -> t (h ys)
                       ≡ DL $ \ys -> t (h' ++ ys)
                       ≡ DL $ \ys -> f' ++ (g' ++ (h' ++ ys))
```

## Строгость в Haskell

### `seq`

Мы будем называть нечто в Haskell как *bottom*, если вычисление данного существа *никогда не заканчивается успешно*, обозначают обычно как `_|_` (это неофициальная записи, такого объекта в Haskell формально нету). Более приближенный к Haskell объектом является `undefined`. `seq` это модель, которая позволяет обойти ленивость Haskell, она принимает два аргумента: первый она вычисляет до WHNF и возвращает (без изменений) второй. В случае, если первый не может быть вычислен, возвращается bottom.

```haskell
seq :: a -> b -> b
_|_ `seq` _ = _|_
_   `seq` b = b
```

Примеры `seq`.

```haskell
ghci> 0 `seq` 10
10
-- `0` - есть конструктор числа типа `Int` (для пример), поэтому
-- она находится в WHNF
```

```haskell
ghci> undefined `seq` 10
-- *** Exception: Prelude.undefined
-- `undefined` не находился в WHNF, программа попыталась вычислить его,
--  получала Exception, так как мы попытались посчитать `undefined`
```

```haskell
ghci> Just undefined `seq` 10
10
-- `Just undefined` НАХОДИТСЯ в WHNF (так как конструктор), поэтому его нет
-- необходимости считать - вернули второй аргумент
```

```haskell
data    DataWrapper a    = DW a
newtype NewtypeWrapper a = NW a

ghci> DW undefined `seq` 42
42
-- `DW` - это `data`, а значит, у него `DW` - это КОНСТРУКТОР, а значит,
-- он - `DW undefined` - находится в WHNF

ghci> NW undefined `seq` 42
-- *** Exception: Prelude.undefined
-- `NW` - это `newtype`, а значит, у него `NW` НЕ ЯВЛЯЕТСЯ конструктором (стирается), а значит,
-- он -- `NW undefined` - не находится в WHNF, попытались посчитать и нарвались
-- на `undefined`
```

#### `foldl` vs. `foldr`

По умолчанию, и `foldl`, и `foldr` медленные, так как они работают со списком и применяют операции в некотором порядке.

```haskell
module Main where

main :: IO ()
main = print $ foldr (+) 0 [1..10^7]
```

На $10^7$ элемента `foldr` сможет досчитать, но через достаточно долгое время. А вот на $10^8$ ваша система может попросту упасть. Внезапно, проблема оказывается в отсутствии строгости. Ведь существуют *строгие* версии этих двух функций `foldl'` и `foldr'`, соответственно.

```haskell
module Main where

import Data.List (foldl')

main :: IO ()
main = print $ foldl' (+) 0 [1..10^7]
```

На $10^7$ элементах `foldl'` (и его правая сверточная версия) считает сумму практически моментально. На $10^8$, конечно, медленее, но, по крайней мере, оно не сломает вашу систему.

Поймем, в чем дело, обратившись к определению двух свёрток. Как мы знаем, реализация этих двух выглядит следующим образом.

```haskell
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr _ z []     = z
foldr f z (x:xs) = x `f` foldr f z xs
-- посчитали `x`, применили функцию `f` - по ленивости пошли досчитывать `foldr`

foldl :: (b -> a -> b) -> b -> [a] -> b
foldl _ z []     = z
foldl f z (x:xs) = foldl f (z `f` x) xs
-- посчитали рекурсивный `foldl`, затем - `x` с функцией
```

А теперь рассмотрим повнимательнее на функцию `sum` (это `fold*` с операцией сложения).

```haskell
sum [1, 2, 3] ≡ foldr (+) 0 [1, 2, 3]
              ≡ 1 + foldr (+) 0 [2, 3]
              ≡ 1 + (2 + foldr (+) 0 [3])
              ≡ 1 + (2 + (3 + foldr (+) 0 []))
              ≡ 1 + (2 + (3 + 0))
              ≡ 1 + (2 + 3)
              ≡ 1 + 5
              ≡ 6
-- здесь мы полностью раскрываем весь список и начиная справа считать в аккумулятор
```

```haskell
sum [1, 2, 3] ≡ foldl (+) 0 [1, 2, 3]
              ≡ foldl (+) (0 + 1) [2, 3]
              ≡ foldl (+) ((0 + 1) + 2) [3]
              ≡ foldl (+) (((0 + 1) + 2) + 3) []
              ≡ ((0 + 1) + 2) + 3
              ≡ (1 + 2) + 3
              ≡ 3 + 3
              ≡ 6
-- здесь мы также полностью раскрываем список и считать, но обратим внимание на
-- невозможность применения shirt-circuit функций, например, `(&&)`
```

В обоих случаях мы видим довольно очевидную проблему - мы не думаем о том, чтобы начать сразу считать значения прямо в рекурсии, что приводит к возрастанию дерева вычисления до гигантских размеров. "Строгие" версии данных функций используют идею `seq`: давайте мы посчитаем временный thunk и сразу получим значение, вместо того, чтобы создавать огромное дерево. Казалось бы, для этого давайте применим сам `seq`.

```haskell
foldl' :: (a -> b -> a) -> a -> [b] -> a
foldl' f a []     = a
foldl' f a (x:xs) = let a' = f a x
                    -- сначала посчитаем значением (оно не посчитается, так как лень)
                    in seq a' (foldl' f a' xs)
                    -- затем, мы-таки досчитаем его до WHNF и, поскольку это индификатор
                    -- мы сможем его посчитанное значение переиспользовать в `foldl`
```

Однако, он не то чтобы был 100% полезен для более сложных случаев кроме чисел. Например, мы захотим посчитать значения внутри пар, а как мы знаем пара - это конструктор `(,)`, а конструктор и есть метка на WHNF... Представим себе тот же `seq`, который бы считал вообще всё, что можно посчитать - такой есть, имя ему - `deepseq`.

```haskell
ghci> import Control.DeepSeq
ghci> [1, 2, undefined] `seq` 3
3
-- список - это WHNF, так как это синтаксический сахар над 1:2:undefined:[]
-- значит, получаем WHNF, возвращаем `3`

ghci> [1, 2, undefined] `deepseq` 3
*** Exception: Prelude.undefined
-- `deepseq` пойдет в список и попытается посчитать вообще каждый элемент, в том числе
-- и `undefined` - вылетает с ошибкой
```

##### `NFData`

Для волшебной `deepseq`-функции нам нужен специальный type class для работы, по двум основным причинам:

1. мы умеем и хотим создавать свои структуры данных, у них, очевидно, свои есть поля, которые нам нужно вычислять как-то по своему
2. нам нужна рекурсия

Для этого и был определен type class, именуемый как `NFData`, у которой определена одна функция `rnf` (или: *reduce normal form*). Нужен этот класс и функция как раз для подсчета в нормальную форму значения (напоминание: normal form - это по сути весь целостный объект).

```haskell
class NFData a where
  rnf :: a -> ()
  rnf a = a `seq` ()
```

А зачем нам здесь `seq` и `()`?  Второе нам нужно для работы `deepseq`, а первое нам нужно для того, чтобы `a` точно посчиталось (в данном случае: до нормальной формы). Причем, мы здесь определяем `NFData` уже с готовой функцией, так как очень многие алгебраические типы, очевидно, не нуждаются в дополнительном подсчёте (например, `Int`). Определим для нескольких типов instance от `NFData`.

```haskell
instance NFData a => NFData (Maybe a) where
  rnf Nothing  = ()
  -- `Nothing` - мы возвращаем сразу `Unit` значение для остановки рекурсии
  rnf (Just x) = rnf x
  -- достали значение `a` и запустили для неё `rnf` для принудительного счёта

instance NFData a => NFData [a] where
  rnf []     = ()
  -- так как пустой список, давайте вернём `Unit` значение для остановки рекурсии
  rnf (x:xs) = rnf x `seq` rnf xs
  -- принудительно считаем голову списка, а затем оставшуюся часть, заметим,
  -- что мы используем `seq` - опять же для того, чтобы `rnf x` хотя бы начал считаться
```

Наконец, сама функция `deepseq` (уже как реальная функция, а не как модель `seq`) совместит идею двух предыдущих.

```haskell
deepseq :: NFData a => a -> b -> b
a `deepseq` b = rnf a `seq` b
```

#### Расширение языка `BangPatterns`

Существует расширения языка, позволяющий проводить `seq` без необходимости прописывать его явным образом. В функциях перед применением индификатором где-либо нужно раньше прописать имя индификатора с символом восклицательного знака без пробел от названия индификатора.

```haskell
{-# LANGUAGE BangPatterns #-}

sum :: Num a => [a] -> a
sum = go 0
  where
    go !acc (x:xs) = go (acc + x) xs
    -- перед правой частью, `acc` посчитается до WHNF
    go  acc []     = acc
```

По большей части, `!` - это просто синтаксический сахар, ничего нового оно не приносит. Некоторые примеры использования.

```haskell
g (!x, y) = [x, y]
-- можно использовать непосредственно в функциях, перед применением константы
```

```haskell
let (!x, [y]) = e in b
-- можно использовать в части `let`-`in`, сначала посчитав значение, а
-- потом использовать его в выражении после `in`
```

```haskell
stackOps :: State Stack Int  -- type Stack = [Int]
stackOps = do
  !x <- pop
  -- можно также использовать внутри нотации `do`, сначала получить из `pop`
  -- монадический объект, а потом посчитать его
  push 42
  return x
```

В данном расширении можно также встретить "почти строгую" и "точно строгую" версию оператора применения функции - `$`.

```haskell
($!) :: (a -> b) -> a -> b -- "почти строгая", так как здесь `seq`
f $! x = let !vx = x in f vx

($!!) :: (NFData a) => (a -> b) -> a -> b  -- "точно строгая", так как здесь `deepseq`
f $!! x = x `deepseq` f x
```

### Ленивый Pattern Matching

Представим себе, что мы по какой-то причине хотим ленивым образом сделать попадание по образцу, так как он оказывается слишком жестоким и вычисляет всё (как было уже сказано ранее) до WHNF (вернее, требует такой записи).

```haskell
f :: (a, b) -> Int
f (a, b) = const 1 a -- слишком строго, требуем, чтобы было ровно два элемента

ghci> f undefined
-- *** Exception: Prelude.undefined
-- по какой-то причине мы очень хотим сделать так и вернуть 1
```

Для таких случаев был введен специальный `~`, который позволяет сказать, что то, что справа от него - является настолько ленивым, чтобы не считать по каким-то причинам.

```haskell
g :: (a, b) -> Int
g ~(a, b) = const 1 a -- ленивый pattern matching

ghci> g undefined
1
-- теперь `undefined`, несмотря на то, что он не находится в WHNF, не будет
-- пытаться быть посчитанным, как раньше
```

А как вообще работает тильда? По сути происходит следующее, давайте рассмотрим это в виде итераций.

1. Оригинальная запись, пока ничего не менялось.

    ```haskell
    g :: (a, b) -> Int
    g ~(a, b) = const 1 a
    ```

2. Далее, мы заменим `~(a, b)` на некоторый индификатор `p`, который, как раз-таки, и не будет пытаться попасть по образцу.

    ```haskell
    g :: (a, b) -> Int
    g p = const 1 a
    ```

3. Остаётся как-то убрать `a` справа, так как он не определен здесь. Формально, у нас заводится длинная лямбда функция, которая с успехом сможет сделать pattern matching.

    ```haskell
    g :: (a, b) -> Int
    g p = const 1 ((\p -> case p of (a, b) -> a) p)
    ```

Почему же данную особенность никто не использует? Мы используем много конструкторов для каких-то `data`-объектов, однако, здесь, мы полностью *игнорируем* существование конструктора, так как не доводим до WHNF. Например, списки.

```haskell
lazyHead :: [a] -> a
lazyHead ~[]    = undefined
lazyHead ~(x:_) = x
```

В данном кусочке кода компилятор нам скажет, что вторая строчка redundant. Заметим, что у списка существует ДВА конструктора: `:` и `[]`, а это значит, что после применения `~` у нас получилось две функции, которые принимают какой-то индификатор, а не pattern matching. А значит, по любому вызову мы получим `undefined`-исключение. А если поменяем местами, то мы получим ожидаем поведение на непустом списке, однако, на пустом мы получим совершенно не то - отсутствие pattern matching по пустому списку.

Тоже самое касается и `Either`: у него два конструктора, а значит различить их с помощью `~` мы никаким образом не сможем.

```haskell
f1 :: Either e Int -> Int
f1 ~(Right 1) = 42

ghci > f1 (Left "the hehes")
42
ghci > f1 (error "and the hahas")
42
```

### Строгий Haskell

Чего мы добивались всё это время, добавляя какие-то детали строгости? Отсутствия space leak - это висячее в памяти множество байтов, которое долгое время может не использоваться и попросту занимать место. Мы можем явно указать для каких-то типов-полей в `data` объекте строгость, используя `!` перед названием типа, тогда именно это поле будет всегда считаться строжайшим образом.

```haskell
data Config = Config -- строгие поля
  { users :: !Int
  , extra :: !(Maybe Settings)  
  } deriving (Show)
```

Мы можем задать по умолчанию строгость `data` объектов и их полей через прагму `StrictData`.

```haskell
{-# LANGUAGE StrictData #-}

data Config = Config -- все поля строгие
  { users ::  Int
  , extra ::  Maybe Settings
  } deriving (Show)
```

Однако, если мы хотим сделать вообще всё в проекте строгим, тогда ставим `Strict` прагму (можно вообще в `package.yaml` указать распространение на весь проект), в таком случае мы полностью перекрываем одну из идей Haskell.

Где вообще следует использовать такой зверь как строгость?

1. Если что-то пошло не так (работает медленно, или падает из-за StackOverflow/OutOfMemory), следует проанализировать и добавить строгости там, где идёт сильно накопление.
2. Есть смысл всегда делать строгими арифметические операции - они занимают не очень много места, но как уже было рассмотрено в `foldl`/`foldr` их в большинстве будет занимать предостаточно места.
3. В дополнении первого пункта, мы можем уменьшить число посчитанных значений или вызываемых функций (особенно, когда есть рекурсия) с помощью строгости.

    ```haskell
    f x  = g $! (h x) -- оптимизируем вызов `h x` с помощью принудительного запуска
    f x  = g x        -- ничего не оптимизируем
    f !x = g (h x)    -- оптимизируем `x` с помощью принудительного подсчёта
    ```

4. Как уже было рассмотрено выше: мы можем преуменьшить проблемы через строгие поля `data`.

Также, на исправление space leak'ов в `foldl`/`foldr` можно использовать [библиотеку](https://www.stackage.org/package/foldl) строго `fold`-объекта.

## Оптимизация прохода по списку

### Deforestation

Возвращаясь к теме про занимаемое место в памяти промежуточных объектов мы частенько забываем про такую функцию как `map` и используем его, генерируя промежуточный объект для вычисления функции `f` на элементах списках. Посмотрим на такой пример:

```haskell
map2 :: (b -> c) -> (a -> b) -> [a] -> [c]
map2 f g l = (map f . map g) l
```

Здесь мы проходимся по списку ДВАЖДЫ, так как мы явно вызываем функцию `map` ДВАЖДЫ, и, причем, в данном случае, вероятнее всего, мы посчитаем функцию `f` и заменим `g`. Долго и нужное место тратится. Немного перепишем.

```haskell
map2 :: (b -> c) -> (a -> b) -> [a] -> [c]
map2 f g l = map (f . g) l
```

Намного лучше: мы проходимся только один, применяя композицию функций `f` и `g`, чтобы, как минимум, в два раза быстрее предыдущей версии.

Посмотрим теперь внимательно на функцию `map`, мы знаем как её можно реализовать без `case` выражения.

```haskell
map :: (a -> b) -> [a] -> [b]
map _ []     = []
map f (x:xs) = f x : map f xs
```

Но теперь перепишем в эквивалентную форму с использованием `case`.

```haskell
map :: (a -> b) -> [a] -> [b]
map f l = case l of
               []     -> []
               (x:xs) -> f x : map f xs
```

Внезапно, но именно `case` станет основным флагманом в переписывании функций c $n$ вызываемыми разами проходу по списку на уменьшение их количества. **Deforestation** (или: *вырубка деревьев*) - это преобразование программы, направленное на устранение промежуточных списков или древовидных структур, которые создаются, а затем немедленно потребляются программой.

Попробуем преобразовать ручным методом следующую функцию. Данные шаги не являются общими и могут сильно варьировать в зависимости от функции.

```haskell
func = foldr (+) 0 . map (\x -> x * 10)
```

1. Для наглядности давайте уберем $\eta$-редукцию и композицию функцию.

    ```haskell
    func l = foldr (+) 0 (map (\x -> x * 10) l)
    ```

2. Зачем нам запускать функцию `foldr`, если у нас пустой список? Давайте не будем и используем впервые `case`.

    ```haskell
    func l = case (map (\x -> x * 10) l) of [] -> 0
                                            (x:xs) -> x + (foldr (+) 0 xs)  
    ```

3. Тоже самое можно сказать и про `map` - зачем нам вообще хоть что-то делать, если у нас пустой список? Давайте сразу вернём его.

    ```haskell
    func l = case (case l of [] -> []
                            (y:ys) -> y * 10 : map (\x -> x * 10) ys) of
                  [] -> 0
                  (x:xs) -> x + (foldr (+) 0 xs)  
    ```

4. Применим такую технику как `case-of-case` преобразование, что потом увидеть, что можно сократить и убрать.

    ```haskell
    func l = case l of [] -> (case [] of [] -> 0
                                         (x:xs) -> x + (foldr (+) 0 xs))
                       (y:ys) -> (case (y * 10 : map (\x -> x * 10) ys) of
                                       [] -> 0
                                       (x:xs) -> x + (foldr (+) 0 xs)) 
    ```

5. Предпоследний шаг: уберём те части кода, которые никогда не исполнятся; например, в `case [] of ...` бесполезен случай `(x:xs)`.

    ```haskell
    func l = case l of [] -> 0
                      (y:ys) -> y * 10 + (foldr (+) 0 (map (\x -> x * 10) ys))
    ```

6. Наконец, мы получили все ещё мешающий нам `foldr` - но это же в точности наша функция `func`, так как мы также умножаем на 10 и складываем.

    ```haskell
    func l = case l of [] -> 0
                      (y:ys) -> y * 10 + func ys
    ```

Мы избавились два прохода, заменив на один проход.

### Stream Fusion

Для быстрого и почти автоматического создания оптимизированных проходов по списку и применений тех или иных операций используется идея стримов (похожих в каком-то плане на Stream из Java) и свойств ленивости применения функций и композиции операций. Для создания подобного нам нужен, так называемый, *экзистенциальный тип*.

```haskell
data Step s a = Done | Skip s | Yield a s
-- есть три вариант шага:
--   - либо, это конец стрима, `Done`
--   - либо, мы пропускаем данный элемент (например, при фильтрации), `Skip s`
--   - либо, это один из элементов стрима, `Yield a s`


data Stream a = forall s . Stream (s -> Step s a) s
-- в данном случае `s` - это тип контейнера, где лежат элементы,
-- тип `a` - это тип одного элемента
```

А что такое `forall`? Вспоминаем математическую логику, оттуда, по Карри-Хорворда, мы знаем следующее

$$
\forall s.\phi\to\psi\to\exists s.\phi\to\psi\\
\forall s.(\phi\to\psi)\to((\exists s.\phi)\to\psi)
$$

Внутри компилятора GHC происходит тоже самое: `forall` сжирает всё, что лежит справа и превращает в внутренний `exists` (при первом проходе компиляции).

```haskell
ghci> :t Stream
Stream :: forall s . ((s -> Step s a) -> s -> Stream a)
-- Stream :: forall s . (((s -> Step s a), s) -> Stream a)
-- Stream :: (exists s . ((s -> Step s a), s)) -> Stream a
```

Что по итогу? Функция `s -> Step s a` - это экстрактор из стрима (один шаг при обработке), `s` - это сам по себе стрим. Теперь разберемся над созданием стрима: поскольку сам `Stream` принимает типовой параметр `s` - так давайте мы подадим в качестве `s` список элементов, который мы хотим превратить в стрим, тогда и в самом шаге мы будем брать список и делать шаг непосредственно по нему.

```haskell
stream :: forall a . [a] -> Stream a
stream xs = Stream next xs 
  where
    next :: [a] -> Step [a] a
    next []     = Done -- конец списка
    next (x:xs) = Yield x xs
```

По такому же методу мы создаем `unstream` - из стрима в список. Здесь мы используем функцию `next`, чтобы получить следующий элемент, а дальше проверяем по типу шага.

```haskell
unstream :: forall a . Stream a -> [a]
unstream (Stream next s0) = go s0 
  where
    go s = case next s of 
             Done       -> []
             Skip s'    -> go s'
             Yield a s' -> a : go s'
```

По такому же принципу мы можем реализовать `map` и `filter` (здесь мы ставим по предикату либо `Skip`, либо `Yield`). Причем, здесь мы меняем функцию перехода, не меняя структуру массива или стрима.

```haskell
mapS :: forall a b . (a -> b) -> Stream a -> Stream b
mapS f (Stream next s) = Stream next' s 
  where
    next' xs = case next xs of 
                    Done       -> Done
                    Skip s'    -> Skip s'
                    Yield a s' -> Yield (f a) s'
```

```haskell
filterS :: forall a . (a -> Bool) -> Stream a -> Stream a
filterS p (Stream next s) = Stream next' s 
  where
    next' xs = case next xs of 
                    Done       -> Done
                    Skip s'    -> Skip s'
                    Yield a s' -> if p a then Yield a s' else Skip s'
                    -- не проходит по условию: пропускаем
```

Наконец, стандартная функция `map`/`filter` переписывается на стримы достаточно легко - главное, что мы должны использовать именно композицию функций.

```haskell
map :: (a -> b) -> [a] -> [b]
map f = unstream . mapS f . stream
-- `stream`   - создали новый стрим
-- `mapS f`   - применение функции `a -> b` по элементам стрима
-- `unstream` - из стрима мы получили привычный список
```

```haskell
filter :: (a -> Bool) -> [a] -> [a]
filter p = unstream . filterS p . stream
```

А если что-то посложнее? Мы рискуем напороться на композицию `stream . unstream`, чтобы сошлось по типам, - очевидно, это долго и явно не то, чего хотели. Здесь нам поможет [*Rewrite rules*](https://downloads.haskell.org/ghc/latest/docs/users_guide/exts/rewrite_rules.html) - как раз здесь и взыграет роль введённый экзистенциальный тип `Stream` - мы можем подсказать таким образом компилятору, что `stream . unstream` даст тот же стрим, а значит, нам нету необходимости явным образом проделывать это.

```haskell
{-# RULES "stream/unstream" 
    forall (s :: Stream a) . stream (unstream s) = s 
  #-}
```

## Изменяемые объекты

### `ST`

Вспомним про `IO` - по сути, это был специальный `State#`, который возвращал новое состояния в виде волшебного `RealWorld` (полностью компиляторная штука, недоступная пользователю).

```haskell
newtype IO a = IO { unIO :: State# RealWorld -> (State# RealWorld, a) }
```

А теперь давайте представим себе тот же тип, но только для общих случаев. Почему бы нам не хранить всё в оперативной памяти и не использовать указатель на хранимый объект? Встречайте, `ST`.

```haskell
newtype ST s a = ST (State# s -> (# State# s, a #))
-- в данном случае, (# State# s, a #) - это реальный tuple в виде возвращаемых
-- рядом объектов (например, через регистры)
```

Заметим, что в общем-то `ST` напоминает `IO` и как будто второй является частным случаем.. В целом, вы будете правы, опять же по модулю того, как выглядит `RealWorld`. Рассмотрим основную функцию `runST` - она нужна вообще везде и является первым и необходимым. Но есть проблема: это видимый тип `s`, чтобы это исправить мы используем трюк с `forall`.

```haskell
runST :: (forall s. ST s a) -> a
```

Наконец, подобно `IORef`, как мы уже выяснили ранее, есть более общий `STRef` - изменяемая переменная.

```haskell
data STRef s a
```

Функции для работы у неё ровно такие же, как и с функциями для `IO` объектов.

```haskell
newSTRef    :: a -> ST s (STRef s a) 
readSTRef   :: STRef s a -> ST s a
writeSTRef  :: STRef s a -> a -> ST s ()
modifySTRef :: STRef s a -> (a -> a) -> ST s () 
```

Наконец, посмотрим на пример вычисления с помощью такой переменной. Обращаем внимания, что мы не используем ни грязные функции, ни `unsafe` и у нас всё является чистым.

```haskell
import Control.Monad.ST
import Data.STRef
import Data.Foldable

sumST :: Num a => [a] -> a
sumST xs = runST $ do
  n <- newSTRef 0
  for_ xs $ \x ->
      modifySTRef n (+x)
  readSTRef n
```

### `MArray`

Для изменяемых массивов был также создан монад-тип как `ST` именуемый как `MArray`.

```haskell
class Monad m => MArray a e m where ...
-- где, `m` - это тип монады,
--      `e` - это тип элемента
--      `a` - это тип массива
```

Существует два вида массива: для `boxed` и `unboxed` типов. `boxed` тип - это тот, который не требует динамически выделенной памяти (например, на стеке или регистре), такие как `Double`, `Bool` и так далее, `unboxed`, соответственно, для `String`, например.

На `boxed` типы существует `STUArray` тип, на `unboxed` - `STArray`.

```haskell
data STArray s i e :: * -> * -> * -> *
-- где, `s` - состояние аргумента-переменной для `ST`
--      `i` - тип индекса (должен быть instance Ix), обычно используется `Int`, но может быть что-то 64-битное
--      `e` - тип элемента в массиве

data STUArray s i e
```

У массивов есть подобные `ST` функции для работы с ними.

```haskell
newArray   :: Ix i => (i, i) -> e -> m (a i e)
readArray  :: (MArray a e m, Ix i) => a i e -> i -> m e
writeArray :: (MArray a e m, Ix i) => a i e -> i -> e -> m ()
```

### `Vector` и `MVector`

Существует два вида векторов: изменяемый `MVector` (требует в качестве типа тип состояния) и неизменяемый `Vector`. С вторым никаких сложностей при работе нету, в отличии от обычного списка, у `Vector` индексация и slice'инг работают за $\mathcal{O}(1)$. С первым немного страшнее: там используется `PrimMonad`.

```haskell
class Monad m => PrimMonad m where
  primitive
  -- тип `primitive` неизвестен, пока не будет instance

-- Что это такое? На самом деле, это - иерархия вложенности трансформеров:

instance PrimMonad m => PrimMonad (ExceptT e m)
instance PrimMonad m => PrimMonad (WriterT w m)
instance PrimMonad m => PrimMonad (ReaderT e m)
```

Но какой фундамент у `PrimMonad`? Поскольку мы работаем с изменяемыми объектами, то его база: `PrimMonad IO` и `PrimMonad (ST s)` (базовые instance'ы).

Сами методы у `MVector` выглядят довольно страшно - и они как раз и используют `PrimMonad`.

```haskell
read   :: (PrimMonad m, MVector v a) => v (PrimState m) a -> Int -> m a
write  :: (PrimMonad m, MVector v a) => v (PrimState m) a -> Int -> a -> m ()
grow   :: PrimMonad m => MVector (PrimState m) a -> Int -> m (MVector (PrimState m) a)
freeze :: PrimMonad m => MVector (PrimState m) a -> m (Vector a)
```
