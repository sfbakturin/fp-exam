# Ускорение Haskell

## `DList`

Рассмотрим довольно медленную операцию в Haskell - конкатенация списков - само это действие долгое и тяжелое по причине неизменяемости объектов (приходится копировать). Однако, даже здесь можно сделать ещё хуже скорость. Представим себе функцию `trinity`, которая бы конкатенировала три списка в один.

```haskell
trinity :: [a] -> [a] -> [a] -> [a]
trinity a b c = a ++ b ++ c   -- (1)
trinity a b c = a ++ (b ++ c) -- (2)
trinity a b c = (a ++ b) ++ c -- (3)
```

Вопрос, какой из подход хуже по скорости и памяти? Мы помним, что `(++)` имеет правую ассоциацию, а значит варианты (1) и (2) полностью эквивалентны. Хуже всех (3): потому что мы хотим к более короткому присоединять, так как у последнего нам нужно обновить ссылку на следующую ноду последнего узла. Посмотрим повнимательнее на оператор `(++)`.

```haskell
infixr 5 ++
(++) :: [a] -> [a] -> [a]
[]     ++ b = b
(x:xs) ++ b = x : (xs ++ b) -- конструктор `:`
```

Не забываем, что у нас все вычисления ленивы, а значит мы проходимся только по первому аргументу (второй может быть бесконечным) с pattern-matching. Более понятный пример.

```haskell
a = [1..n] ++ ([1..m] ++ [1..k]) -- сначала конкатенируем то, что в скобках
  = [1..n] ++ [1..m, 1..k]       -- получили O(m) операций
  = [1..n, 1..m, 1..k]           -- получили O(n) операций
                                 -- итого O(n + m)
```

```haskell
b = ([1..n] ++ [1..m]) ++ [1..k] -- сначала конкатенируем то, что в скобках
  = [1..n, 1..m] ++ [1..k]       -- получили O(n) операций
  = [1..n, 1..m, 1..k]           -- получили O(n + m) операций
                                 -- итого O(2 * n + m) операций
```

Нам приходится слишком много думать о том, как правильно расставить скобки, а хотелось бы иметь волшебный тип, который бы сам умел "расставлять" правильным образом скобки. В этом нам поможет *Difference List* или `DList`. Выглядит этот зверь следующим образом.

```haskell
newtype DList a = DL { unDL :: [a] -> [a] }
```

Для него определены две и ещё одна по определению операции: `fromList`, `toList` и `append`.

```haskell
fromList :: [a] -> DList a
fromList l = DL (l++)
-- принимает список и возвращает обёртку `DList`
-- обратим внимание на `(l++)` - это правая связка, а значит,
-- `(l++)` раскрывается в `(\l' -> l ++ l')`

toList :: DList a -> [a]
toList (DL lf) = lf []
-- принимаем обёртку `DList` и возвращаем список
-- по определению `fromList`, `toList` - это `l ++ []`
-- сохраняется свойство моноида: нейтральный элемент

append :: DList a -> DList a -> DList a
append (DL f) (DL g) = DL (\xs -> f (g xd))
-- принимаем две обёртки и возвращаем новую конкатенацию
-- замечаем, что сохраняется свойство полугруппы: (a <> b) <> c == a <> (b <> c)
```

А теперь поймем, почему же это лучше, чем список (казалось бы, мы добавляем слева `l`). Рассмотрим два случая: `(f <> g) <> h` и `f <> (g <> h)` - раскрыв в виде объектов и скобки (как операция `append`) мы обнаружим, что эти обе операции, во первых, одинаковы, а во вторых выводят последнюю конкатенацию в виде ожидаемой: `f' ++ (g' ++ (h' ++ ...))` - а этот случай, как уже разбиралось ранее, намного лучше, чем `(((f' ++ g') ++ h') ++ ...)`.

```haskell
DL f <> (DL g <> DL h) ≡ DL f <> DL (\xs -> g (h xs)) 
                       ≡ DL f <> DL (\xs -> g' ++ (h' ++ xs))  -- t ≡ (\xs -> ...)
                       ≡ DL f <> DL t
                       ≡ DL $ \ys -> f (t ys)
                       ≡ DL $ \ys -> f' ++ (t ys)
                       ≡ DL $ \ys -> f' ++ (g' ++ (h' ++ ys))
```

```haskell
(DL f <> DL g) <> DL h ≡ DL (\xs -> f (g xs)) <> DL h 
                       ≡ DL (\xs -> f' ++ (g' ++ xs)) <> DL h  -- t ≡ (\xs -> ...)
                       ≡ DL t <> DL h
                       ≡ DL $ \ys -> t (h ys)
                       ≡ DL $ \ys -> t (h' ++ ys)
                       ≡ DL $ \ys -> f' ++ (g' ++ (h' ++ ys))
```

## Строгость в Haskell

### `seq`

Мы будем называть нечто в Haskell как *bottom*, если вычисление данного существа *никогда не заканчивается успешно*, обозначают обычно как `_|_` (это неофициальная записи, такого объекта в Haskell формально нету). Более приближенный к Haskell объектом является `undefined`. `seq` это модель, которая позволяет обойти ленивость Haskell, она принимает два аргумента: первый она вычисляет до WHNF и возвращает (без изменений) второй. В случае, если первый не может быть вычислен, возвращается bottom.

```haskell
seq :: a -> b -> b
_|_ `seq` _ = _|_
_   `seq` b = b
```

Примеры `seq`.

```haskell
ghci> 0 `seq` 10
10
-- `0` - есть конструктор числа типа `Int` (для пример), поэтому
-- она находится в WHNF
```

```haskell
ghci> undefined `seq` 10
-- *** Exception: Prelude.undefined
-- `undefined` не находился в WHNF, программа попыталась вычислить его,
--  получала Exception, так как мы попытались посчитать `undefined`
```

```haskell
ghci> Just undefined `seq` 10
10
-- `Just undefined` НАХОДИТСЯ в WHNF (так как конструктор), поэтому его нет
-- необходимости считать - вернули второй аргумент
```

```haskell
data    DataWrapper a    = DW a
newtype NewtypeWrapper a = NW a

ghci> DW undefined `seq` 42
42
-- `DW` - это `data`, а значит, у него `DW` - это КОНСТРУКТОР, а значит,
-- он - `DW undefined` - находится в WHNF

ghci> NW undefined `seq` 42
-- *** Exception: Prelude.undefined
-- `NW` - это `newtype`, а значит, у него `NW` НЕ ЯВЛЯЕТСЯ конструктором (стирается), а значит,
-- он -- `NW undefined` - не находится в WHNF, попытались посчитать и нарвались
-- на `undefined`
```

#### `foldl` vs. `foldr`

По умолчанию, и `foldl`, и `foldr` медленные, так как они работают со списком и применяют операции в некотором порядке.

```haskell
module Main where

main :: IO ()
main = print $ foldr (+) 0 [1..10^7]
```

На $10^7$ элемента `foldr` сможет досчитать, но через достаточно долгое время. А вот на $10^8$ ваша система может попросту упасть. Внезапно, проблема оказывается в отсутствии строгости. Ведь существуют *строгие* версии этих двух функций `foldl'` и `foldr'`, соответственно.

```haskell
module Main where

import Data.List (foldl')

main :: IO ()
main = print $ foldl' (+) 0 [1..10^7]
```

На $10^7$ элементах `foldl'` (и его правая сверточная версия) считает сумму практически моментально. На $10^8$, конечно, медленее, но, по крайней мере, оно не сломает вашу систему.

Поймем, в чем дело, обратившись к определению двух свёрток. Как мы знаем, реализация этих двух выглядит следующим образом.

```haskell
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr _ z []     = z
foldr f z (x:xs) = x `f` foldr f z xs
-- посчитали `x`, применили функцию `f` - по ленивости пошли досчитывать `foldr`

foldl :: (b -> a -> b) -> b -> [a] -> b
foldl _ z []     = z
foldl f z (x:xs) = foldl f (z `f` x) xs
-- посчитали рекурсивный `foldl`, затем - `x` с функцией
```

А теперь рассмотрим повнимательнее на функцию `sum` (это `fold*` с операцией сложения).

```haskell
sum [1, 2, 3] ≡ foldr (+) 0 [1, 2, 3]
              ≡ 1 + foldr (+) 0 [2, 3]
              ≡ 1 + (2 + foldr (+) 0 [3])
              ≡ 1 + (2 + (3 + foldr (+) 0 []))
              ≡ 1 + (2 + (3 + 0))
              ≡ 1 + (2 + 3)
              ≡ 1 + 5
              ≡ 6
-- здесь мы полностью раскрываем весь список и начиная справа считать в аккумулятор
```

```haskell
sum [1, 2, 3] ≡ foldl (+) 0 [1, 2, 3]
              ≡ foldl (+) (0 + 1) [2, 3]
              ≡ foldl (+) ((0 + 1) + 2) [3]
              ≡ foldl (+) (((0 + 1) + 2) + 3) []
              ≡ ((0 + 1) + 2) + 3
              ≡ (1 + 2) + 3
              ≡ 3 + 3
              ≡ 6
-- здесь мы также полностью раскрываем список и считать, но обратим внимание на
-- невозможность применения shirt-circuit функций, например, `(&&)`
```

В обоих случаях мы видим довольно очевидную проблему - мы не думаем о том, чтобы начать сразу считать значения прямо в рекурсии, что приводит к возрастанию дерева вычисления до гигантских размеров. "Строгие" версии данных функций используют идею `seq`: давайте мы посчитаем временный thunk и сразу получим значение, вместо того, чтобы создавать огромное дерево. Казалось бы, для этого давайте применим сам `seq`.

```haskell
foldl' :: (a -> b -> a) -> a -> [b] -> a
foldl' f a []     = a
foldl' f a (x:xs) = let a' = f a x
                    -- сначала посчитаем значением (оно не посчитается, так как лень)
                    in seq a' (foldl' f a' xs)
                    -- затем, мы-таки досчитаем его до WHNF и, поскольку это индификатор
                    -- мы сможем его посчитанное значение переиспользовать в `foldl`
```

Однако, он не то чтобы был 100% полезен для более сложных случаев кроме чисел. Например, мы захотим посчитать значения внутри пар, а как мы знаем пара - это конструктор `(,)`, а конструктор и есть метка на WHNF... Представим себе тот же `seq`, который бы считал вообще всё, что можно посчитать - такой есть, имя ему - `deepseq`.

```haskell
ghci> import Control.DeepSeq
ghci> [1, 2, undefined] `seq` 3
3
-- список - это WHNF, так как это синтаксический сахар над 1:2:undefined:[]
-- значит, получаем WHNF, возвращаем `3`

ghci> [1, 2, undefined] `deepseq` 3
*** Exception: Prelude.undefined
-- `deepseq` пойдет в список и попытается посчитать вообще каждый элемент, в том числе
-- и `undefined` - вылетает с ошибкой
```

##### `NFData`

Для волшебной `deepseq`-функции нам нужен специальный type class для работы, по двум основным причинам:

1. мы умеем и хотим создавать свои структуры данных, у них, очевидно, свои есть поля, которые нам нужно вычислять как-то по своему
2. нам нужна рекурсия

Для этого и был определен type class, именуемый как `NFData`, у которой определена одна функция `rnf` (или: *reduce normal form*). Нужен этот класс и функция как раз для подсчета в нормальную форму значения (напоминание: normal form - это по сути весь целостный объект).

```haskell
class NFData a where
  rnf :: a -> ()
  rnf a = a `seq` ()
```

А зачем нам здесь `seq` и `()`?  Второе нам нужно для работы `deepseq`, а первое нам нужно для того, чтобы `a` точно посчиталось (в данном случае: до нормальной формы). Причем, мы здесь определяем `NFData` уже с готовой функцией, так как очень многие алгебраические типы, очевидно, не нуждаются в дополнительном подсчёте (например, `Int`). Определим для нескольких типов instance от `NFData`.

```haskell
instance NFData a => NFData (Maybe a) where
  rnf Nothing  = ()
  -- `Nothing` - мы возвращаем сразу `Unit` значение для остановки рекурсии
  rnf (Just x) = rnf x
  -- достали значение `a` и запустили для неё `rnf` для принудительного счёта

instance NFData a => NFData [a] where
  rnf []     = ()
  -- так как пустой список, давайте вернём `Unit` значение для остановки рекурсии
  rnf (x:xs) = rnf x `seq` rnf xs
  -- принудительно считаем голову списка, а затем оставшуюся часть, заметим,
  -- что мы используем `seq` - опять же для того, чтобы `rnf x` хотя бы начал считаться
```

Наконец, сама функция `deepseq` (уже как реальная функция, а не как модель `seq`) совместит идею двух предыдущих.

```haskell
deepseq :: NFData a => a -> b -> b
a `deepseq` b = rnf a `seq` b
```

#### Расширение языка `BangPatterns`

Существует расширения языка, позволяющий проводить `seq` без необходимости прописывать его явным образом. В функциях перед применением индификатором где-либо нужно раньше прописать имя индификатора с символом восклицательного знака без пробел от названия индификатора.

```haskell
{-# LANGUAGE BangPatterns #-}

sum :: Num a => [a] -> a
sum = go 0
  where
    go !acc (x:xs) = go (acc + x) xs
    -- перед правой частью, `acc` посчитается до WHNF
    go  acc []     = acc
```

По большей части, `!` - это просто синтаксический сахар, ничего нового оно не приносит. Некоторые примеры использования.

```haskell
g (!x, y) = [x, y]
-- можно использовать непосредственно в функциях, перед применением константы
```

```haskell
let (!x, [y]) = e in b
-- можно использовать в части `let`-`in`, сначала посчитав значение, а
-- потом использовать его в выражении после `in`
```

```haskell
stackOps :: State Stack Int  -- type Stack = [Int]
stackOps = do
  !x <- pop
  -- можно также использовать внутри нотации `do`, сначала получить из `pop`
  -- монадический объект, а потом посчитать его
  push 42
  return x
```

В данном расширении можно также встретить "почти строгую" и "точно строгую" версию оператора применения функции - `$`.

```haskell
($!) :: (a -> b) -> a -> b -- "почти строгая", так как здесь `seq`
f $! x = let !vx = x in f vx

($!!) :: (NFData a) => (a -> b) -> a -> b  -- "точно строгая", так как здесь `deepseq`
f $!! x = x `deepseq` f x
```

### Ленивый Pattern Matching

Представим себе, что мы по какой-то причине хотим ленивым образом сделать попадание по образцу, так как он оказывается слишком жестоким и вычисляет всё (как было уже сказано ранее) до WHNF (вернее, требует такой записи).

```haskell
f :: (a, b) -> Int
f (a, b) = const 1 a -- слишком строго, требуем, чтобы было ровно два элемента

ghci> f undefined
-- *** Exception: Prelude.undefined
-- по какой-то причине мы очень хотим сделать так и вернуть 1
```

Для таких случаев был введен специальный `~`, который позволяет сказать, что то, что справа от него - является настолько ленивым, чтобы не считать по каким-то причинам.

```haskell
g :: (a, b) -> Int
g ~(a, b) = const 1 a -- ленивый pattern matching

ghci> g undefined
1
-- теперь `undefined`, несмотря на то, что он не находится в WHNF, не будет
-- пытаться быть посчитанным, как раньше
```

А как вообще работает тильда? По сути происходит следующее, давайте рассмотрим это в виде итераций.

1. Оригинальная запись, пока ничего не менялось.

    ```haskell
    g :: (a, b) -> Int
    g ~(a, b) = const 1 a
    ```

2. Далее, мы заменим `~(a, b)` на некоторый индификатор `p`, который, как раз-таки, и не будет пытаться попасть по образцу.

    ```haskell
    g :: (a, b) -> Int
    g p = const 1 a
    ```

3. Остаётся как-то убрать `a` справа, так как он не определен здесь. Формально, у нас заводится длинная лямбда функция, которая с успехом сможет сделать pattern matching.

    ```haskell
    g :: (a, b) -> Int
    g p = const 1 ((\p -> case p of (a, b) -> a) p)
    ```

Почему же данную особенность никто не использует? Мы используем много конструкторов для каких-то `data`-объектов, однако, здесь, мы полностью *игнорируем* существование конструктора, так как не доводим до WHNF. Например, списки.

```haskell
lazyHead :: [a] -> a
lazyHead ~[]    = undefined
lazyHead ~(x:_) = x
```

В данном кусочке кода компилятор нам скажет, что вторая строчка redundant. Заметим, что у списка существует ДВА конструктора: `:` и `[]`, а это значит, что после применения `~` у нас получилось две функции, которые принимают какой-то индификатор, а не pattern matching. А значит, по любому вызову мы получим `undefined`-исключение. А если поменяем местами, то мы получим ожидаем поведение на непустом списке, однако, на пустом мы получим совершенно не то - отсутствие pattern matching по пустому списку.

Тоже самое касается и `Either`: у него два конструктора, а значит различить их с помощью `~` мы никаким образом не сможем.

```haskell
f1 :: Either e Int -> Int
f1 ~(Right 1) = 42

ghci > f1 (Left "the hehes")
42
ghci > f1 (error "and the hahas")
42
```

### Строгий Haskell

Чего мы добивались всё это время, добавляя какие-то детали строгости? Отсутствия space leak - это висячее в памяти множество байтов, которое долгое время может не использоваться и попросту занимать место. Мы можем явно указать для каких-то типов-полей в `data` объекте строгость, используя `!` перед названием типа, тогда именно это поле будет всегда считаться строжайшим образом.

```haskell
data Config = Config -- строгие поля
  { users :: !Int
  , extra :: !(Maybe Settings)  
  } deriving (Show)
```

Мы можем задать по умолчанию строгость `data` объектов и их полей через прагму `StrictData`.

```haskell
{-# LANGUAGE StrictData #-}

data Config = Config -- все поля строгие
  { users ::  Int
  , extra ::  Maybe Settings
  } deriving (Show)
```

Однако, если мы хотим сделать вообще всё в проекте строгим, тогда ставим `Strict` прагму (можно вообще в `package.yaml` указать распространение на весь проект), в таком случае мы полностью перекрываем одну из идей Haskell.

Где вообще следует использовать такой зверь как строгость?

1. Если что-то пошло не так (работает медленно, или падает из-за StackOverflow/OutOfMemory), следует проанализировать и добавить строгости там, где идёт сильно накопление.
2. Есть смысл всегда делать строгими арифметические операции - они занимают не очень много места, но как уже было рассмотрено в `foldl`/`foldr` их в большинстве будет занимать предостаточно места.
3. В дополнении первого пункта, мы можем уменьшить число посчитанных значений или вызываемых функций (особенно, когда есть рекурсия) с помощью строгости.

    ```haskell
    f x  = g $! (h x) -- оптимизируем вызов `h x` с помощью принудительного запуска
    f x  = g x        -- ничего не оптимизируем
    f !x = g (h x)    -- оптимизируем `x` с помощью принудительного подсчёта
    ```

4. Как уже было рассмотрено выше: мы можем преуменьшить проблемы через строгие поля `data`.

Также, на исправление space leak'ов в `foldl`/`foldr` можно использовать [библиотеку](https://www.stackage.org/package/foldl) строго `fold`-объекта.
