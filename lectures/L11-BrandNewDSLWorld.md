# Разверзнись, новый DSL мир

**Main Specific Language** - это определенный набор команд функций и тех или иных функциональностей, которые позволяют работать с определенной доменной областью. Грубо говоря, это задачи, которые решают те или иные языки программирования: **GSL** (*general specific language*) - обычно про Python/Java/C++ - те языки программирования, которые умеют решать множество задач, а **DSL** - про Verilog, например.

## GADT

Попробуем привести пример, где мы бы хотели заиметь что-то новое от Haskell в плане типизации. Хотим сделать объекты для математических выражений (сложение, оператор-БОЛЬШЕ и логический-И). Воспользуемся старым добрым Haskell'ким ADT.

```haskell
data ArithExpr =
    AENum Int
  | AEPlus ArithExpr ArithExpr
  | AEAnd ArithExpr ArithExpr
  | AEGt ArithExpr ArithExpr
```

И создадим пример-выражение.

```haskell
-- (23 + 12) > 170 && (35 > 47)
myExpr =
  ((AENum 23 `AEPlus` AENum 12) `AEGt` AENum 170)
  `AEAnd` (AENum 35 `AEGt` AENum 47)
```

В чем может быть проблема? В том, что мы можем подать в качестве выражения в импровизированную функцию `eval` выражение вида `12 && 23`.

```haskell
badExpr = AENum 12 `AEAnd` AENum 23
```

Для решения этой проблемы используется другой (заместо ADT) механизм типов - **GADT** - *Generalized algebraic data types*. В чём именно проблема? Заметим, что `AENum` не хранит информацию о том, что внутри него лежит какое-то число.

```haskell
ghci> :t AENum
AENum  :: Int -> ArithExpr
-- что там дальше в `ArithExpr` мы тоже не знаем
```

Синтаксис интересуемого GADT выглядит следующим образом - он ничем не отличается от развёрнутого синтаксиса `data`, поэтому введём сразу типовой аргумент:

```haskell
-- `a` - типовой аргумент
data ArithExpr a where
  AENum  :: Int -> ArithExpr
  AEPlus :: ArithExpr Int -> ArithExpr Int -> ArithExpr Int
  -- нас появился типовой параметр, пропишем его везде, где он возможен
  -- в данном случае: мы хотим складывать Int'ы
  AEAnd  :: ArithExpr Bool -> ArithExpr Bool -> ArithExpr Bool
  -- в данном случае: мы хотим использовать только на Bool'ах
  AEGt   :: ArithExpr Int -> ArithExpr Int -> ArithExpr Bool
  -- в данном случае: мы принимаем Int'ы, но возвращаем Bool
```

Теперь, если мы хотим что-то посчитать, нужно протягивать типы. Зато, мы сможем избавиться от необходимости проверять на правильность типов `Int`/`Int`, `Bool`/`Bool`. Что ещё хорошего? То, что было верно - вообще никак не меняется, а то, что не было - будет считаться неверным выражением. Причем, происходит это на этапе компиляции - типы не совпадут.

## Экзистенциальные типы
